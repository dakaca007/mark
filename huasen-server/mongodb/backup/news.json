{
  "RECORDS": [
    {
      "bannerImg": "huasen-public-static/admin/1650133543049.png",
      "code": "0",
      "content": "# 背景介绍\n\n> 2022年春节  晴 10°C 西北风\n\n步入社会，自由支配的时间一点点地被工作侵蚀。开发维护网站的时间变少，可偏偏是屋漏偏逢连夜，2月份网站遭到严重的攻击，联系了腾讯云的工程师仍然无法解决，最终不得已重置服务器，被迫关停网站。网站关停的一段时间里，我寻找原因，针对地加固服务器，同时吸取之前使用者提出的建议，反正网站都被攻击到重置服务器了，一不做二不休，干脆直接更新网站！\n\n\n\n# 更新内容\n\n> 测试反馈阶段\n\n1. 切换简洁模式功能；\n2. 免登录备份恢复功能，使用本地缓存增加用户体验，支持不登录情况下使用全部功能；\n3. 订阅信息源功能，支持选择自己喜爱的信息内容；\n4. 自定义背景主题的，支持选择纯色背景、预设图片、上传本地图片，可以调节文字颜色、背景模糊度、明暗；\n5. 重构后端服务，针对性加固服务器，提升安全性，增加了请求缓存、加密信息、权限校验、非法日志记录等诸多功能；\n\n\n\n# 即将推出\n\n> 冒烟开发阶段\n\n- 增加个人中心模块，支持头像、昵称、密码修改、数据清空、账号注销功能；\n- 完善订阅功能；\n- 后端支持消息队列，缓解并发造成的阻塞现象；\n- 开源全部内容；\n\n\n\n# 未来计划\n\n> 挠头预研阶段\n\n1. 低代码拖拽编辑器，集成组件库，拖拽开发、页面复现二次开发的低代码编辑工具；\n2. 协同流程图，支持点对点数据传输，实现协同制作流程图；\n\n\n\n# 版本快照\n\n### 2022年\n\n![ZC8VS6r49chKz5n](https://s2.loli.net/2022/04/19/ZC8VS6r49chKz5n.png)\n\n### 2021年\n\n![ciMkewy8OCznQWK](https://s2.loli.net/2022/04/19/ciMkewy8OCznQWK.png)\n\n### 2020年\n\n![WSBAtsOCkomNu1U](https://s2.loli.net/2022/04/19/WSBAtsOCkomNu1U.png)\n\n### 2019年\n\n![ShqOWVJDx6rLC74](https://s2.loli.net/2022/04/19/ShqOWVJDx6rLC74.png)",
      "isDraft": "false",
      "publisher": "932397243@qq.com",
      "tag": "记录/版本快照/更新内容/未来计划",
      "time": "2022-4-19",
      "title": "更新日志"
    },
    {
      "bannerImg": "huasen-public-static/admin/1650137863899.png",
      "code": "0",
      "content": "# 人生初见\n\n> Ctrl + D 收藏本站\n\n```javascript\n你好 // 普通话\nmwngz ndei // 壮语\nhello // 英语\nconsole.log('你好') // JS\n```\n\n# 心境\n\n> 森林覆盖的岛屿花开遍地美好都将与约而至\n\n从大三决然的跳入前端大坑，到如今已是毕业一年的杭州社畜。脑子依旧清晰地记得，我选择前端时的孤独，周围都是清一色的后端方向，图书馆里我与灯为伴，以书为友。三年光阴不长不短，似乎在别人眼里我一直在变着花样开发烂大街的网址导航，我不以为然。只道是不悔梦归处，空恨时间太匆匆。在一路的成长中伴随着孤独，我相信那么一句话，念念不忘，必有回响。\n\n# 初衷\n\n深知如今使用百度引擎获取优质的内容困难性，祸源在于是百度搜索存在严重的竞价排名的现象，一句话就是只要有钱，我就能让你搜索不到你想要的内容。甚至会搜索到大量的伪劣内容以及捆绑软件，好巧不巧，小森喜欢查阅资料，搜集免费实用的优质资源，涵盖了日常生活、娱乐、学习、影视、考研、工作、科技、实用工具诸多领域。于是这个网站诞生了，希望能够帮助到大家，愿大家在繁杂喧闹的互联网信息时代，细品出一丝我们给予您的一些美好！\n\n# 免责声明\n\n网站是致力于营造高效简洁地上网冲浪环境的公益性平台，本站严格遵守中华人民共和国相关法律，不存在破解、串改、贩卖数据等违法行为，一切资源均来源于各大免费论坛社区，包括提供的体验账号，仅供大家学习参考，请勿用于商业用途，违反者造成损失及法律责任与本人无关。如有不幸侵犯到您的权益，请联系小森，我们将全面积极配合！\n\n# 联系我们\n\n企鹅🐧：184820911\n\n邮箱📮：[184820911@qq.com](184820911@qq.com)\n\n哔哩哔哩：[花森酱JioJio](https://space.bilibili.com/241546158)\n\n\n\n\n\n",
      "isDraft": "false",
      "publisher": "932397243@qq.com",
      "tag": "介绍/声明/点滴",
      "time": "2022-5-14",
      "title": "关于我们"
    },
    {
      "bannerImg": "huasen-public-static/admin/1650137865490.png",
      "code": "0",
      "content": "# 离线使用\n\n为了照顾不愿注册登录的小伙伴，我推出了离线使用的功能。用户在不登录的情况下，数据保存在浏览器中，仍然可以体验网站的全部功能。如果不小心卸载浏览器，或者清空浏览器记录会造成数据丢失，所以还是比较推荐注册登录，同步备份自己的数据。\n\n## 切换模式\n\n网站存在两种模式，资源模式中可以看到全部内容，极简模式十分干净，仅显示一个搜索框。切换模式后会本地记录保存，刷新或重启浏览器都不会改变模式。\n\n![qrQEYdHWUGPNRZb](https://s2.loli.net/2022/04/18/qrQEYdHWUGPNRZb.gif)\n\n## 背景修改\n\n用户可以自定义喜欢的背景，支持更改为预设的纯色背景、预设图片、上传图片，支持调节字体、模糊度、遮罩功能，本地上传图片，建议尺寸`1920*1080`，并且大小不超过1M ！\n\n![qQs8oxZrjfTuK3c](https://s2.loli.net/2022/04/18/qQs8oxZrjfTuK3c.gif)\n\n## 自定义网站\n\n用户可以手动添加、删除、修改自定义的网站，数据是存储在浏览器内部，虽然重启浏览器或者刷新都不会消失，但是如果不小心卸载浏览器或者清除浏览器数据会丢失数据。希望小伙伴们定时拷贝保存自定义的数据，以免造成数据丢失！\n\n![tWrNDMcj2VfUAo8](https://s2.loli.net/2022/04/18/tWrNDMcj2VfUAo8.gif)\n\n## 备份恢复\n\n1. 点击”拷贝“按钮，自定义的网站数据将会复制到剪贴板，用户可以自行粘贴保存；\n2. 复制之前保存的字符串，点击”恢复“按钮后，在弹出输入框中粘贴数据，确认即可恢复数据；\n\n![pNo8K2BHRw396dI](https://s2.loli.net/2022/04/19/pNo8K2BHRw396dI.gif)\n\n## 切换搜索引擎\n\n认识到百度搜索引擎的流氓行为，我贴心地准备了切换搜索引擎的功能，用户选择使用引擎进行搜索冲浪，十分推荐大家尝试体验，提醒一下，谷歌搜索引擎需要科学上网！\n\n![1AL8vmip7TfZzPF](https://s2.loli.net/2022/04/19/1AL8vmip7TfZzPF.gif)\n\n\n\n# 拓展功能\n\n离线功能存储的数据浏览器之间不能共享，如果存在切换浏览器、更换设备、卸载浏览器、清空浏览器的情况下，自定义的内容将无法同步共享。因此强烈推荐小伙伴注册账号，登录备份数据到云端，实现跨设备共享自定义的数据。\n\n## 登录注册\n\n注册时需要填写邮箱接收验证码，密码仅支持“数字+字母”的组合，不支持符号。注册成功后通过邮箱+密码的方式登录。若7天内如果不使用网站，则登录状态失效，备份时需要重新登录。\n\n![fyveSP67E2oLsNJ](https://s2.loli.net/2022/04/18/fyveSP67E2oLsNJ.gif)\n\n## 同步备份云端\n\n每次自定义修改信息后，数据都会先保留在浏览器中，需要我们手动备份数据到云端。若我们在设备A中修改并且备份，设备B需要退出账号，再次登录方可看到最新数据。提醒小伙伴，登录后自动同步，数据将会覆盖本地，请注意备份保存。\n\n![A8vYkRSgcMPLFDO](https://s2.loli.net/2022/04/19/A8vYkRSgcMPLFDO.gif)\n\n\n\n# 贡献力量\n\n如果你想贡献网链或者文章，请联系站长，并且携带如下图片资源！\n\n1. 网站图标默认尺寸`100*100`;\n2. 文章封面默认尺寸`240*380`;\n\n",
      "isDraft": "false",
      "publisher": "932397243@qq.com",
      "tag": "帮助/说明书/教程/快速上手",
      "time": "2022-4-18",
      "title": "使用说明书"
    },
    {
      "bannerImg": "huasen-public-static/admin/1650133541053.png",
      "code": "0",
      "content": "# ECMAScript\n\nJavaScript 官方名称是 `ECMAScript` 是一种属于网络的脚本语言，已经被广泛用于Web应用开发，常用来为网页添加各式各样的动态功能，为用户提供更流畅美观的浏览效果。\n\n\n\n\n\n# 编辑器\n\nVscode是一款微软出品的强大前端编辑器，具有很强的拓展性，常用插件有如下类型：\n\n1. live server服务器形式运行代码，ctrl+s保存自动刷新代码；\n2. auto rename tag标签更改后自动补全；\n3. Bracket Pair Colorizer 2代码语法高亮；\n4. Prettier Code formatter代码格式化，需要进入vscode设置，搜索save关键词，勾选format on save选项；\n5. vue代码高亮；\n\n\n\n\n\n# 代码执行顺序\n\n由于程序由上往下执行，避免程序页面延迟，将js代码放入body的尾部。 script标签按顺序执行，引入模块代码延后执行。\n\n\n\n\n\n# 命名规则\n\n数字、字母、下划线、$符号均可以作为变量名的组成部分，但是要注意不能以数字开头和关键名命名，例如：while、class等关键词均不可以使用。\n\n\n\n\n\n# 声明关键字\n\n### var\n\n1. var声明的变量没有块级作用域，仅有函数作用域，重复命名会覆盖；\n\n```javascript\nif (1) {\n  var a = 6;\n  let b = 9;\n}\nconsole.log(a); // 6\nconsole.log(b); // b is not defined\n```\n\n2. var声明变量造成变量提升（先使用后申明），环境在执行代码之前优先将解析变量并放入堆中，未定义的变量优先定义为undefined，不会发生报错的现象，打开严格模式也不会进行报错；\n\n```javascript\na = 3;\nalert(a);\nvar a;\n\n// 真实的执行顺序\n1.var a;\n2.a = 3;\n3.alert(a);\n```\n\n### let\n\n1. let需要先声明后否则使用会造成TDC暂时性死区（报错）；\n2. 存在块级作用域；\n3. 同一作用域下不可以重复声明；\n\n### const\n\n1. 定义后的常量不可改变;\n2. 声明的同时必须赋值；\n3. 当const是对象等引用类型常量时只要地址不变即可；\n4. 拥有块、函数、全局作用域；\n\n### 无关键词\n\n无关键词定义全局变量会造成全域污染，导致变量冲突难以调试的问题。\n\n### object.freeze变量冻结\n\n非严格模式下变量被冻结后再次被使用不会报错，而开启严格模式后控制台会进行报错。\n\n```javascript\n\"use strict\"\nconst INFO = {\n  url: 'https://n.huasenjio.top/',\n  port: '8080'\n};\nObject.freeze(INFO);\nINFO.port = '443'; //Cannot assign to read only property\nconsole.log(INFO);\n```\n\n\n\n\n\n# 作用域\n\n### 1.块级作用域\n\nif、while、for语句形成块级作用域，var声明的变量是没有块级作用域，可以穿透块级作用域。\n\n```javascript\n<script>\n  if (1) {\n    var a = 9;\n    console.log(\"1是逻辑值为真\");\n  }\nconsole.log(a); // 输出9\n</script>\n```\n\n### 2.函数作用域\n\n当声明函数时会在函数的内部形成一个函数的作用域，let和const声明的变量有块级作用和函数作用域，var也不能穿透函数作用域。所以可以用函数作用域来解决var无块级作用域的缺点。\n\n```javascript\n<script>\n  function b() {\n  var a = 9;\n}\nconsole.log(a); // a is not defined\n</script>\n```\n\n\n\n\n\n# 传值与传址\n\n### 1.传值\n\n函数传递参数时，基本数据类型的赋值是直接传递值。\n\n### 2.传址\n\n引用类型的复合对象的赋值是传递地址\n\n\n\n\n\n# 严格模式\n\n1. 变量需要先声明再使用；\n2. 必须使用关键词声明变量；\n3. 匿名函数的this不再指向window对象而是undefined；\n4. 非规范写法会在严格模式下报错；\n\n\n\n\n\n# 运算符\n\n### 1.数学运算符\n\n```javascript\nlet a = 4;\nlet b = 5\nconsole.log(3 % 2); // 1，取余；\nconsole.log(3 / 2); // 1.5，除法；\nconsole.log(a++); // 5，自加运算符，此时a=4，但这条指令执行完成后a+1；\nconsole.log(--b); // 6，自减运算符，此时a=6，执行这段代码前b+1；\n```\n\n### 2.比较运算符\n\n比较运算符分为两个，`“==”`和`“===”`，双等号的运算符比较时会将等式两边的数据变成相同的数据类型再比较，这个特点叫隐式转换；三等号运算符称为严格比较，不会转变为相同的数据类型来比较，数据类型不同就返回false。\n\n```javascript\n<script>\n  // undefined仅与null和本身相等\n  console.log(0 == undefined); //false;\n\tconsole.log(\"\" == undefined); //false;\n\tconsole.log([] == undefined); //false;\n\tconsole.log({} == undefined); //false;\n\tconsole.log(undefined == null); //true\n</script>\n```\n\n### 3.三目运算符\n\n`表达式 ? 表达式为真时 ：表达式为假时`，可以嵌套使用。\n\n\n\n\n\n# 循环控制\n\n### 1.if\n\n```javascript\nif (1) {\n  // 表达式为真的代码块\n} else {\n  // 表达式为假的代码块\n}\n```\n\n### 2.for\n\n```javascript\nfor (let i = 0; i < 10; i++) {\n  // 执行代码块\n}\n```\n\n### 3.for-in\n\nfor-in遍历数组时，根据下标遍历，遍历对象时是根据属性名遍历。\n\n```javascript\nlet arr = [\"森\", \"酱\", \"与\", \"猪\"];\nlet obj = {\n  name: \"花森\",\n  sex: \"男\",\n};\n// 遍历数组\nfor (const key in arr) {\n  console.log(key); //下标\n  console.log(arr[key]);\n}\n\n// 遍历对象\nfor (const key in obj) {\n  console.log(key); // name sex\n  console.log(obj[key]); // 花森 男\n}\n```\n\n### 4.for-of\n\nfor-of是根据数组内的元素进行遍历，可以遍历迭代器对象。\n\n```javascript\nlet arr = [\"森\", \"酱\", \"与\", \"猪\"]\n\nfor (const item of arr) {\n  console.log(item); // 森 酱...\n}\n```\n\n### 5.forEach\n\n```javascript\nlet arr = [\"森\", \"酱\", \"与\", \"猪\"];\narr.forEach((item, index, arr) => {\n  console.log(item); // 元素\n  console.log(index); // 下标\n  console.log(arr); // 原数组\n});\n```\n\n### 6.while\n\n```javascript\nvar a = 0;\nwhile (1) {\n  a++;\n  if (a == 10) {\n    continue; // 跳过a = 10并直接进入a=11循环\n  }\n  console.log(a);\n\n  if (a == 20) {\n    break; // 跳出结束循环\n  }\n}\n```\n\n### 7.switch\n\n不设置break会造成穿透效果\n\n```javascript\nlet name = '视频';\nswitch (name) {\n    case '产品':\n        console.log('huasen');\n        break;\n    case '视频':\n        console.log('zhuqi');\n        break;\n    default:\n        console.log('hs');\n}\n```\n\n### 8.break和continue\n\n1. break跳出当前循环体；\n2. continue跳过本次循环；\n3. 通过label跳出父级循环;\n\n```javascript\nhuasen: for (let i = 1; i <= 10; i++) {\n  zhuqi: for (let n = 1; n <= 10; n++) {\n    if (n % 2 != 0) {\n      continue huasen;\n    }\n    console.log(i, n);\n    if (i + n > 15) {\n      break zhuqi;\n    }\n  }\n}\n```\n\n\n\n\n\n# this指向\n\n匿名函数中的this指向的是window对象（严格模式下指向undefined），可以通过作用域链的方式获取到外部的this，同样也可以通过ES6箭头函数取到父级作用域的this指针。\n\n```javascript\n<script>\n  let huasen = {\n    names: \"花森\",\n    sex: \"男\",\n    showSex: function () {\n      let that = this;\n      function getName() {\n        console.log(this.names); //this指向window，输出 undefined。\n        console.log(that.names); //that指向huasen，作用域链向上查找。\n      }\n      getName(); //调用getName是一个函数getName，它没有没有依靠，因为匿名函数中的this是指向window，所以调用者就是window，所以this就指向window。\n    },\n\n    showName: () => {\n      // 箭头函数默然会指向父级作用域，此处调用showName方法的是huasen，它的父级作用域就是window，this指向window。\n      console.log(\"方法是箭头函数\", this);\n    },\n  };\nhuasen.showSex(); // 男\nhuasen.showName();\n</script>\n```\n\n#### <u>Call与Apply</u>\n\n`函数a.call(对象b，参数1，参数2...)`，函数a将它的this指针指向对象b，同时传递参数的形式是一个一个传递；`函数a.apply(对象b，[参数1，参数2...])`，函数a将它的this指针指向对象b，传递参数的形式是数组，两者更改this指向后不会立刻执行函数，bind的方式绑定this会立即执行该函数。\n\n```javascript\nfunction User(name, type = \"人类\") {\n  this.name = name;\n  this.type = type;\n  showType = function () {\n    console.log(this.name);\n  };\n  // 默认会返回一个生成后的实例\n  return this;\n}\nfunction Pig(name, type = \"猪\") {\n  this.name = name;\n  this.type = type;\n  showType = function () {\n    console.log(this.name);\n  };\n}\nconsole.log(new User(\"花森\", \"人类\"));\nlet zhuqi = {\n  name: \"李琦\",\n  sex: \"女\",\n};\n// User.call(zhuqi, \"猪琦\", \"猪\"); // 通过call将User函数的this指向zhuqi对象，call通过一个一个参数传入，最后返回this再次指向zhuqi，相同属性名会遭到覆盖。\nUser.apply(zhuqi, [\"猪琦\", \"猪\"]); // apply的不同点是通过数组直接传入参数，其他效果一致。\nconsole.log(zhuqi); //{sex: \"女\", name: \"猪琦\", type: \"猪\"}\n```\n\n#### <u>Bind</u>\n\nbind()是将函数绑定到某个对象，比如 a.bind(hd) 可以理解为将a函数绑定到hd对象上即 hd.a()。绑定后会立即执行函数，bind是赋值函数行为会返回一个新的函数。\n\n```javascript\nfunction hs(a, b) {\n  console.log(this);\n  return this.f + a + b;\n}\n\n//使用bind会生成新函数\nlet newFunc = hs.bind({ f: 1 }, 3); // 将函数hs绑定给了对象{f:1}\n\n//1+3+2 参数2赋值给b即 a=3 b=2\nconsole.log(newFunc(2));\n```\n\n\n\n\n\n# 数据类型检测\n\n### 1.typeof\n\n基本数据类型检测，无法辨别数组和对象，合适基本的数据类型辨别，具体可以辨别如下类型：\n\n1. number/string/boolean；\n2. function；\n3. object；\n4. undefined；\n\n```javascript\nlet a = 1;\nconsole.log(typeof a); //number\n\nlet b = \"1\";\nconsole.log(typeof b); //string\n\n//未赋值或不存在的变量返回undefined\nvar huasen;\nconsole.log(typeof huasen);\n\nfunction run() {}\nconsole.log(typeof run); //function\n\nlet c = [1, 2, 3];\nconsole.log(typeof c); //object\n\nlet d = { name: \"n.huasenjio.top\" };\nconsole.log(typeof d); //object\n```\n\n### 2.instanceof\n\n`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上，就是它是否存于某一个继承的链，如果是数组，那么他的祖先就必定存在Array构造函数，如此进行精准判断数据类型；\n\n```javascript\nlet hs = [];\nlet huasen = {};\nconsole.log(hs instanceof Array); //true\nconsole.log(huasen instanceof Array); //false\n\nlet c = [1, 2, 3];\nconsole.log(c instanceof Array); //true\n\nlet d = { name: \"n.huasenjio.top\" };\nconsole.log(d instanceof Object); //true\n\nfunction User() {}\nlet hd = new User();\nconsole.log(hd instanceof User); //true\n```\n\n\n\n\n\n# 字面量与对象\n\n当我们声明一个数组`let a =[]`时，同样可以使用`a.push()`方法，只有对象才可以调用方法而Array构造函数的prototype原型上面拥有这个`push`方法，所以推论内部将[]转换成为对象。\n\n```JavaScript\nlet hd = \"huasen\"; // 字面量形式\nlet h = new String(\"hs\"); // 对象的形式\nconsole.log(huasen.length); //6个字符\nconsole.log(h.length); //2个字符\n```\n\n\n\n\n\n# Number\n\nNumber用于表示整数和浮点数，数字是 `Number`实例化的对象，可以使用对象原型上提供的丰富方法。\n\n### 1.数字变量的命名\n\n```javascript\nlet huasen = 3; //字面量形式\nlet h = new Number(3); //对象的形式\nconsole.log(h+3); //6\n```\n\n### 2.判断书否是整数\n\n```javascript\nconsole.log(Number.isInteger(1.2));\n```\n\n### 3.NaN无效数值\n\n```javascript\nconsole.log(Number(\"huasen\")); //声明传参传递数字无效产生NaN\nconsole.log(2 / 'huasen'); //无效的数值计算会产生NaN\nNumber.isNaN(变量) // 判断是否是NaN\nObject.is(对象1,对象2) // 判断两个对象是否相等\n```\n\n### 4.类型转换\n\n使用Number构造函数基本上可以转换所有类型\n\n```javascript\nconsole.log(Number('huasen')); //NaN\nconsole.log(Number(true)); //1\nconsole.log(Number(false));\t//0\nconsole.log(Number('9')); //9\nconsole.log(Number([])); //0\nconsole.log(Number([5]));\t//5\nconsole.log(Number([5, 2])); //NaN\nconsole.log(Number({})); //NaN\n```\n\n### 5.常用方法\n\n1）字符串转数字parseInt：\n\n提取的字符串并去除空白数字字串转变为整数\n\n```javascript\nconsole.log(parseInt('1' * 1));\t//1 隐式转换\nconsole.log(parseInt('  99huasen'));\t//99\nconsole.log(parseInt('18.55'));\t//18 小数点被忽略\n```\n\n2）字符串转为浮点数parseFloat：\n\n```javascript\nconsole.log(parseFloat('  99huasen'));\t//99\nconsole.log(parseFloat('18.55'));\t//18.55且不会忽略小数点\n```\n\n3）浮点数四舍五入toFixed：\n\n```javascript\nconsole.log(1.55667.toFixed(2)); //1.56\n```\n\n\n\n\n\n# String\n\n字符串类型是使用非常多的数据类型\n\n### 1.字符串变量的声明\n\n```javascript\nlet hs = new String('huasen');\n// 获取字符串长度\nconsole.log(hs.length);\n// 获取字符串\nconsole.log(hs.toString());\n\n```\n\n### 2.转义符号\n\n有些字符有双层含义，需要使用 `\\` 转义符号进行含义转换，下例中引号为字符串边界符，如果输出引号时需要使用转义符号。\n\n```javascript\nlet content = '花森 \\'huasenjio.top\\''; // 内部两个'是需要转义\nconsole.log(content); // 花森 'huasenjio,top'\n```\n\n常见转义符号表：\n\n| 符号 | 说明           |\n| ---- | -------------- |\n| \\t   | 制表符         |\n| \\n   | 换行           |\n| \\\\   | 斜杠符号(转义) |\n| \\'   | 单引号         |\n| \"    | 双引号R        |\n\n### 3.连接运算符\n\n```javascript\nlet year = 2019,\nname = '花森导航';\nconsole.log(name + '成立于' + year + '年');\n```\n\n### 4.模板字面量\n\n使用\\`\\`符号包裹的字符串中可以写入引入变量与表达式，变量使用${}放入，并且可以换行而不产生错误。\n\n```javascript\nlet url = 'huasenjio.top';\nconsole.log(`花森导航网址是${url}`); //花森导航网址是huasenjio.top\n```\n\n### 5.标签模板\n\n通过tag方法将字符串和变量分离到两个数组中\n\n```javascript\nlet lesson = 'css';\nlet web = '花森';\ntag `访问${web}学习${lesson}前端知识`;\n\nfunction tag(strings, ...values) {\n    console.log(strings); //[\"访问\", \"学习\", \"前端知识\"]\n    console.log(values); // [\"花森\", \"css\"]\n}\n```\n\n### 6.常用方法\n\n1）使用`length`属性可以获取字符串长度：\n\n```javascript\nconsole.log(\"huasenjio.top\".length)\n```\n\n2）字母大小写转换（toLowerCase和toLowerCase）：\n\n```javascript\nconsole.log('HUASENJIO.top'.toLowerCase()); //huasenjio.top 转小写\nconsole.log('huasenjio.top'.toLowerCase()); //HUASENJIO.TOP 转小写\n```\n\n3）移除字符空白trim：\n\n```javascript\nlet str = '   huasenjio.top  ';\nconsole.log(str.length);\nconsole.log(str.trim().length);\n\nconsole.log(name.trimLeft()); // 删除左空白\nconsole.log(name.trimRight()); // 删除又空白\n```\n\n4）抓取单个字符chatAt：\n\n```javascript\nconsole.log('huasenjio'.charAt(3)) // s 通过下标（0开始）获取到对于的字符\n```\n\n5）数组形式获取字符：\n\n```javascript\nconsole.log('huasenjio'[3]) // 3 数字索引获取字符串\n```\n\n### 7.字符串的截取\n\n#### <u>slice</u>\n\n- 截掉\n\n```javascript\nlet hs = \"12345678\";\nconsole.log(hs.slice(3)); //45678 slice(截掉的个数)\n```\n\n- 截取\n\n```javascript\n// 参数为正数情况\nlet hs = \"12345678\";\nconsole.log(hs.slice(3, 6)); //456 [开始下标,结束下标）\n\n// 参数为负数情况\nconsole.log(hs.slice(-2)); //78 末尾取两个\nconsole.log(hs.slice(1, -2)); //23456 [开始下标，-2(倒数第二个开始)) 第二个参数是负数说明从尾部数\n```\n\n#### <u>substring</u>\n\n- 截掉\n\n```javascript\nlet hs = \"12345678\";\nconsole.log(hs.substring(3));  //45678 substring(截掉的个数)\n```\n\n- 截取\n\n```javascript\nlet hs = \"12345678\";\nconsole.log(hs.substring(3, 6)); //456 [开始下标,结束下标）\nconsole.log(hs.substring(3, 0)); //123 参数中选最小值作为开始下标进行截取\nconsole.log(hs.substring(3, -9)); //123 负数转为0再按最小值作为开始下标进行截取\n```\n\n#### <u>substr</u>\n\n- 截掉\n\n```javascript\nlet hs = \"12345678\";\nconsole.log(hs.substr(3));  //45678 substr(截掉的个数)\n```\n\n- 截取\n\n```javascript\nlet hs = \"12345678\";\nconsole.log(hs.substr(3, 4)); //4567 [开始下标，截取个数]\n\nconsole.log(hs.substr(-3, 2)); //78 [-3,个数]\n```\n\n### 8.查找字符串\n\n#### <u>indexOf检索</u>\n\n从开始（下标为零）进行查找，若查找到返回第一个目标的下标，查找不到返回-1，可以指定开始查找的位置。\n\n```javascript\nconsole.log(\"12345678\".indexOf(\"3\")); //1\nconsole.log(\"12345678\".indexOf(\"5\", 3)); //4 从第3个字符向后搜索\n\n```\n\n#### <u>search检索</u>\n\nsearch() 方法用于检索字符串中指定的子字符串，也可以使用正则表达式搜索进行搜索，返回子串的开始下标。\n\n```javascript\nlet str = \"huasenjio.top\";\nconsole.log(str.search(\"top\"));\nconsole.log(str.search(/top/i));\n```\n\n### 9.字符串替换\n\n#### <u>replace</u>\n\nreplace方法用于字符串的替换操作，默认替换第一个匹配的字符串，如果想要通过全局替换需要配合正则表达式使用。\n\n```javascript\nlet name = \"1122331122\";\nweb = name.replace(\"22\", \"**\");\nconsole.log(web);\n\n// 配合正则完成替换\nlet str = \"2023/02/12\";\nconsole.log(str.replace(/\\//g, \"-\"));\n```\n\n### 10.重复生成repeat\n\n通过已有的字符串生成重复的字符串\n\n```javascript\nfunction star(num = 3) {\n\treturn '*'.repeat(num);\n}\nconsole.log(star());\n```\n\n### 11.字符串分割split\n\n通过某一个符号对字符串进行分割并返回分割后的数组\n\n```javascript\nconsole.log(\"1,2,3\".split(\",\")); //[1,2,3]\n```\n\n### 12.类型转换\n\n```javascript\nlet hs = 99;\nconsole.log(hs.toString()); //99 String类型\n\nlet arr = [\"1\", \"2\", \"3\"];\nconsole.log(arr.toString()); //1,2,3 String类型\n\nlet a = {\n  name: \"huasen\",\n};\nconsole.log(a.toString()); //[object Object] String类型\n```\n\n\n\n\n\n# Math\n\nmath数学对象，提供了很多数学相关的计算方法。\n\n### 1.最大值最小值\n\n```javascript\nconsole.log(Math.min(1, 2, 3)); // 1\nconsole.log(Math.max(1, 2, 3)); // 3\n```\n\n### 2.向上取整ceil\n\n```javascript\nconsole.log(Math.ceil(1.111)); // 2\n```\n\n### 3.向下整数floor\n\n```javascript\nconsole.log(Math.floor(1.555)); // 1\n```\n\n### 4.四舍五入处理round\n\n```javascript\nconsole.log(Math.round(1.5)); //2\n```\n\n### 5.生成随机数random\n\n`random` 方法用于返回 >=0 且 <1 的随机数（包括0但不包括1）\n\n```javascript\nconst number = Math.floor(Math.random() * 5); // [0,5)\nconsole.log(number);\n\nconst number = Math.floor(Math.random() * (5+1)); // [0,5]\nconsole.log(number);\n\nconst number = Math.floor(Math.random() * (5 - 2)) + 2; // [2,5)\nconsole.log(number);\n\nconst number = Math.floor(Math.random() * (5 - 2+1)) + 2; // [2,5]\nconsole.log(number);\n\nX+Math.floor(Math.random()*(Y-X)) // [X,Y)\nX+Math.floor(Math.random()*(Y-X+1)) // [X,Y]\n```\n\n\n\n\n\n# Date\n\n处理日期的方法，通过 `Date` 类型提供的丰富功能可以非常方便的操作。\n\n### 1.时间戳\n\n定义为从格林威治时间1970年01月01日00时00分00秒起至现在的总秒数\n\n### 2.获取当前日期\n\n```javascript\nlet now = new Date();\nconsole.log(now); // Mon Oct 19 2020 21:15:23 GMT+0800 (中国标准时间)\nconsole.log(typeof now); //object\nconsole.log(now * 1); //获取时间戳\n\n//直接使用函数获取当前时间\nconsole.log(Date());\nconsole.log(typeof Date()); //string\n\n//获取当前时间戳单位毫秒\nconsole.log(Date.now());\n```\n\n### 3.时间格式的封装\n\n```javascript\nfunction dateFormat(date, format = \"YYYY-MM-DD HH:mm:ss\") {\n  const config = {\n    YYYY: date.getFullYear(),\n    MM: date.getMonth() + 1,\n    DD: date.getDate(),\n    HH: date.getHours(),\n    mm: date.getMinutes(),\n    ss: date.getSeconds(),\n  };\n  for (const key in config) {\n    format = format.replace(key, config[key]);\n  }\n  return format;\n}\nconsole.log(dateFormat(new Date(), \"YYYY年MM月DD日HH时mm分ss秒\"));\n```\n\n\n\n\n\n# Boolean\n\n布尔类型包括 `true` 与 `false` 两个值\n\n### 1.声明定义\n\n```javascript\nconsole.log(new Boolean(true)); //true 对象形式\nlet hs =true; // true 字面量形式\n```\n\n### 2.隐式转换\n\n逻辑运算符\"==\"进行两个是比较是否相等时，不同的数据类型会造成隐式转换后再比较，属于js中比较难的部分，具体情况如下：\n\n1. 数组和布尔值比较，`[] == true;//false `，空数组转为\"\"再转为0，逻辑值true直接转为1；\n2. 数组符串比较，`[1,2,3] == '1,2,3' // true`，[1,2,3]转换成字符串\"1,2,3\"最后跟字符串比较；\n3. 字符串和数字进行比较，`'1' == 1 // true`，字符串转为数字后与数字1比较；\n4. 字符串和布尔值进行比较，`'1' == true; // true `，字符串转为数字1，布尔值转为数字1，比较相等；\n5. 布尔值和数字比较，`true == 1;/ true`，布尔值转为数字1再比较；\n\n\n\n![LNvO3BlMpdVIWua](https://s2.loli.net/2022/05/19/LNvO3BlMpdVIWua.png)\n\n\n\n有趣的事情是`[] == false和![] == false`的结果都是true，第一个[]数组转为\"\"再转成0，false直接转为0，比较相等；第二个同理，!符号优先级高所以先执行，所以式子就变成`(![]) == false `，估计就能理解了！另外有几个比较的特殊`undefined == null // true`、`NaN == XXX //NaN和任意类型都不等（包括自己）`。\n\n### 3.显示转换\n\n使用 `!!` 转换布尔类型\n\n```javascript\nlet hs = \"\";\nconsole.log(!!hs); //false\nhs = 0;\nconsole.log(!!hs); //false\nhs = null;\nconsole.log(!!hs); //false\nhs = new Date(\"2020-2-22 10:33\");\nconsole.log(!!hs); //true\nhs = [];\nconsole.log(!!hs); //false\nhs = {};\nconsole.log(!!hs); //false\n```\n\n\n\n\n\n# Array\n\n数组是多个变量值的集合，数组是`Array` 对象的实例，Array原型对象上系统预设很多方式可以供我们调用。\n\n### 1.数组的声明\n\n```javascript\nconsole.log(new Array(1, '花森', 'hs')); //[1, \"花森\", \"hs\"]\nconst array = [\"花森\", \"huasen\"];\nconst array = [[\"花森\",\"hs\"], [\"猪琦\",\"zhuqi\"]];\nconsole.log(array[1][0]); // 猪琦\n\nlet hs = Array.of(3);\nconsole.log(hs); // [3]\nhs = new Array(3); // 创建长度为3的空数组\nconsole.log(hs);\n\nhs = Array.of(1, 2, 3);\nconsole.log(hs); //[1, 2, 3]\n```\n\n### 2.类型检测isArray\n\n```javascript\nconsole.log(Array.isArray([1, \"花森\", \"hs\"])); //true\nconsole.log(Array.isArray(9)); //false\n```\n\n### 3.类型转换\n\n#### <u>数组2字符串</u>\n\n大部分数据类型都可以使用`.toString()`和join 函数转换为字符串\n\n```javascript\nconsole.log(([1, 2, 3]).toString()); // 1,2,3 toSring()\n\nconsole.log(String([1, 2, 3])); //1,2,3 构造函数\n\nconsole.log([1, 2, 3].join(\"-\"));//1-2-3 join()\n```\n\n#### <u>伪数组2数组</u>\n\n使用`Array.from`可将类数组转换为数组，类数组指包含 `length` 属性或可迭代的对象，伪数组不具备数组中的某一个方法，一般使用时都要转为数组再进行使用。\n\n```javascript\nlet str = '花森酱';\nconsole.log(Array.from(str)); //[\"花\", \"森\", \"酱\"]\n\nlet user = {\n  0: '花森酱',\n  '1': 18,\n  length: 2\n};\nconsole.log(Array.from(user)); //[\"花森酱\", 18]\n\nlet divs = document.querySelectorAll(\"div\");\nlet hs = [...divs]\n```\n\n#### <u>字符串2数组</u>\n\n使用`split`，将数组中的元素连接成字符串。\n\n```javascript\nlet price = \"99,78,68\";\nconsole.log(price.split(\",\")); //[\"99\", \"78\", \"68\"]\n```\n\n### 4.数组合并拆分\n\n#### <u>展开语法</u>\n\n使用展开语法来合并数组相比 `concat` 要更简单，使用`...` 可将数组展开为多个值。\n\n```javascript\net a = [1, 2, 3];\nlet b = ['a', '花森', ...a];\nconsole.log(b); //[\"a\", \"花森\", 1, 2, 3]\n```\n\n####  <u>concat</u>\n\n`concat`方法用于连接两个或多个数组，返回是一个数组，元素是值类型的是复制操作，如果元素是引用类型还是指向同一对象，属于浅拷贝的操作。\n\n```javascript\nlet arr = [\"hs\", \"花森\"];\nlet hs = [1, 2];\nlet cms = [3, 4];\nconsole.log(arr.concat(hs, cms)); //[\"hs\", \"花森\", 1, 2, 3, 4]\n```\n\n#### <u>copyWithin</u>\n\n使用 `copyWithin` 从数组中复制一部分到同数组中的另外位置，语法说明`array.copyWithin(target, start, end)`，target复制到的索引地址位置，start元素复制的开始索引，end结束的索引。\n\n```javascript\nconst arr = [1, 2, 3, 4,5];\nconsole.log(arr.copyWithin(2, 0, 2)); //[1, 2, 1, 2, 5]\n```\n\n### 5.解构赋值\n\n解构是一种更简洁的赋值特性，可以理解为分解一个数据的结构。\n\n```javascript\n//数组使用\nlet [name, url] = ['花森', 'hs'];\nconsole.log(name);\n\n// 解构函数返回值\nfunction huasen() {\n\treturn ['hs', '花森'];\n}\nlet [a, b] = huasen();\nconsole.log(a); //hs\n\n// 函数参数解构\nfunction hs([a, b], c) {\n  console.log(a, b);\n  console.log(c);\n}\nhs([\"花森\", \"hs\"], \"猪琦\");\n\n// 解构数组\nlet [a, ...b] = ['花森', 'hs', '猪琦'];\nconsole.log(b);  // ['hs', '猪琦'];\n\n// 解构字符串\n\"use strict\";\nconst [...a] = \"huasenjio\";\nconsole.log(a); //Array(9)\n\n// 解构单个变量\nlet [,url]=['花森','huasenjio'];\nconsole.log(url);//huasenjio\n```\n\n### 6.操作元素\n\n```javascript\n// 数组追回元素\nlet arr = [1, \"花森\", \"hs\"];\narr[arr.length] = \"huasenjio\";\nconsole.log(arr); //[1, \"花森\", \"hs\", \"huasenjio\"]\n\n// push批量压入元素，改变数组长度，返回值是元素的数量。\nlet arr = [1, \"花森\", \"hs\"];\narr.push(\"huasenjio\",\"zhuqi\");\nconsole.log(arr); //[1, \"花森\", \"hs\", \"huasenjio\",\"zhuqi\"]\n\n// pop尾弹一个元素，改变数组长度，返回被弹出的元素。\nlet arr = [1, \"花森\", \"hs\"];\narr.pop();\nconsole.log(arr); //[1, \"花森\"]\n\n// shift头弹一个元素，改变数组长度，返回头弹出的元素。\nlet arr = [1, \"花森\", \"hs\"];\nconsole.log(arr.shift());\nconsole.log(arr); //[\"花森\",\"hs\"]\n\n// unshift头插一个元素，改变数组长度，返回值是元素的数量。\nlet arr = [1, \"花森\", \"hs\"];\nconsole.log(arr.unshift(\"爱\"));\nconsole.log(arr); //[\"花森\",\"hs\"]\n\n// fill填充数组，返回填充完成的数组。\nconsole.log(new Array(4).fill(\"hs\")); //[\"hs\", \"hs\", \"hs\", \"hs\"]\n\n```\n\n### 7.数组截取\n\n#### <u>slice截取</u>\n\n使用 `slice` 方法从数组中截取部分元素组合成新数组（并不会改变原数组），不传第二个参数时截取到数组的最后元素。不设置参数默认截取整个数组。\n\n```javascript\nlet arr = [0, 1, 2, 3, 4, 5, 6];\nconsole.log(arr.slice(1, 3)); // [1,2] [开始下标，结束下标]\n\nlet str = \"0123456\";\nconsole.log(str.slice(1, 3)); // 12 [开始下标，结束下标）\n```\n\n#### <u>splice截掉</u>\n\n使用 `splice` 方法可以添加、删除、替换数组中的元素，会对原数组进行改变，返回值为删除的元素。\n\n```javascript\n// [开始下标,删除数量]\nlet arr = [0, 1, 2, 3, 4, 5, 6];\nconsole.log(arr.splice(1, 3)); //返回删除的元素 [1, 2, 3] \nconsole.log(arr); //删除数据后的原数组 [0, 4, 5, 6]\n\n// 通过修改length删除最后一个元素\nlet arr = [\"1\", \"2\"，\"3\"，\"4\"，\"5\"];\narr.length = arr.length - 1;\nconsole.log(arr);\n\n// [开始下标，删除参数，删除位置的新元素]\nlet arr = [0, 1, 2, 3, 4, 5, 6];\nconsole.log(arr.splice(1, 3, 8)); //返回删除的元素 [1, 2, 3]\nconsole.log(arr); //删除数据后的原数组 [0, 8, 4, 5, 6]\n\n// 两个交换位置小案例\nfunction move(array, before, to) {\n  if (before < 0 || to >= array.length) {\n    console.error(\"指定位置错误\");\n    return;\n  }\n  const newArray = [...array];\n  const elem = newArray.splice(before, 1);\n  newArray.splice(to, 0, ...elem);\n  return newArray;\n}\nconst array = [1, 2, 3, 4];\nconsole.table(move(array, 0, 3));\n```\n\n### 8.数组清空\n\n```javascript\n// 更改指针法\nlet user = [{ name: \"hs\" }, { name: \"花森\" }];\nlet cms = user;\nuser = [];\nconsole.log(user); // []\nconsole.log(cms); // [{...},{...}]\n\n// 修改长度法\nlet user = [{ name: \"hs\" }, { name: \"花森\" }];\nuser.length = 0;\nconsole.log(user);\n\n// splice方法删除所有数组元素\nlet user = [{ name: \"hs\" }, { name: \"花森\" }];\nuser.splice(0, user.length);\nconsole.log(user);\n```\n\n### 9.元素查找\n\n#### <u>indexOf</u>\n\n使用 indexOf 从前向后查找元素出现的位置，如果找不到返回 -1，indexOf使用严格模式去匹配，找到则返回第一次出现的下标。\n\n```javascript\nlet arr = [7, 3, 2, 8, 2, 6];\nconsole.log(arr.indexOf(2)); // 2 从前往后查找第一个出现2的下标\n\n// 指定索引向后进行查找\nlet arr = [7, 3, 2, 8, 2, 6];\nconsole.log(arr.indexOf(2, 3)); //4 从第二个元素开始向后查找\n```\n\n#### <u>lastIndexOf</u>\n\n使用 `lastIndexOf` 从后向前查找元素出现的位置，具体使用参考indexOf方法使用。\n\n```javascript\nlet arr = [7, 3, 2, 8, 2, 6];\nconsole.log(arr.lastIndexOf(2)); // 4 从后查找2出现的位置\n```\n\n#### <u>includes</u>\n\n使用 `includes` 查找字符串返回值是布尔类型更方便判断\n\n```javascript\nlet arr = [7, 3, 2, 6];\nconsole.log(arr.includes(8)); //flase\n```\n\n#### <u>find</u>\n\nfind 方法找到后会把值返回出来，找不到则返回值为undefined，返回第一次查找到的词就停止查找。\n\n```javascript\nlet arr = [\n  { name: \"猪琦\", sex: \"女\" },\n  { name: \"花森\", sex: \"男\" },\n  { name: \"皮卡丘\", sex: \"动物\" },\n];\n\nlet find = arr.find(function (item) {\n  return item.name == \"花森\";\n});\n\nconsole.log(find); // {name: \"花森\", sex: \"男\"}\n```\n\n### 10.数组顺序\n\n#### <u>reverse</u>\n\n对数组进行反转输出\n\n```javascript\nlet arr = [1, 4, 2, 9];\nconsole.log(arr.reverse()); //[9, 2, 4, 1]\n```\n\n#### <u>sort</u>\n\nsort方法每次使用两个值进行比较，`Array.sort((a,b) => a-b)`，返回负数a排在b的前，从小到大排序；返回正数则b排在a的前面，返回0时不动。\n\n```javascript\n// 默认从小到大排序\nlet arr = [1, 4, 2, 9];\nconsole.log(arr.sort()); //[1, 2, 4, 9]\n\n// 按某值进行排序\nconsole.log(arr.sort(function (v1, v2) {\n\treturn v2 - v1;\n})); //[9, 4, 2, 1]\n```\n\n### 11.数组拓展函数\n\n#### <u>every一假则假</u>\n\n`every` 用于递归的检测元素，要所有元素操作都要返回真结果才为真，遇到一个不满足条件就立即退出，不再继续遍历下去，最终返回布尔值。\n\n```javascript\nconst user = [\n  { name: \"李四\", js: 89 },\n  { name: \"马六\", js: 55 },\n  { name: \"张三\", js: 78 },\n];\nconst resust = user.every((item, index, arr) => {\n  console.log(item); // 元素\n  console.log(index); // 下标\n  console.log(arr); // 原数组\n  return item.js >= 60;\n});\nconsole.log(resust);\n```\n\n#### <u>some一真则真</u>\n\n使用 `some` 函数可以递归的检测元素，如果有一个返回true。\n\n```javascript\nconst user = [\n  { name: \"李四\", js: 89 },\n  { name: \"马六\", js: 55 },\n  { name: \"张三\", js: 78 },\n];\nconst resust = user.some((item, index, arr) => {\n  console.log(item); // 元素\n  console.log(index); // 下标\n  console.log(arr); // 原数组\n  return item.js >= 60;\n});\nconsole.log(resust);\n```\n\n#### <u>filter</u>\n\n按一定条件筛选元素并组成新数组返回\n\n```javascript\nconst user = [\n  { name: \"李四\", js: 89 },\n  { name: \"马六\", js: 55 },\n  { name: \"张三\", js: 78 },\n];\nconst resust = user.filter((item, index, arr) => {\n  console.log(item); // 元素\n  console.log(index); // 下标\n  console.log(arr); // 原数组\n  return item.js > 60; // 过滤取到js成绩大于60的元素并返回一个新的数组\n});\nconsole.log(resust);\n```\n\n#### <u>map</u>\n\n将遍历数组，遍历过程中执行代码，最后返回一个元素添加到新数组中并返回。\n\n```javascript\nconst user = [\n  { name: \"李四\", js: 89 },\n  { name: \"马六\", js: 55 },\n  { name: \"张三\", js: 78 },\n];\nconst resust = user.map((item, index, arr) => {\n  console.log(item); // 元素\n  console.log(index); // 下标\n  console.log(arr); // 原数组\n  item.js > 60;\n  return item.js + \"分数\";\n});\nconsole.log(resust);\n```\n\n#### <u>reduce</u>\n\n使用 `reduce` 与 `reduceRight` 函数可以迭代数组的所有元素，`reduce` 从前开始 `reduceRight` 从后面开始，存在如下参数：\n\n| 参数  | 说明                       |\n| ----- | -------------------------- |\n| prev  | 上次调用回调函数返回的结果 |\n| cur   | 当前的元素值               |\n| index | 当前的索引                 |\n| array | 原数组                     |\n\n```javascript\nconst user = [\n  { name: \"李四\", js: 89 },\n  { name: \"马六\", js: 55 },\n  { name: \"张三\", js: 78 },\n];\nconst resust = user.reduce((pre, cur, index, arr) => {\n  console.log(cur); // 当前元素\n  console.log(index); // 下标\n  console.log(pre); // 上一个遍历的元素\n  return \"返回值\"; // 返回值将作为pre参数\n}, 0); // 0指定pre的初始值\n\n//计算所有js成绩的和\nconst user = [\n  { name: \"李四\", js: 89 },\n  { name: \"马六\", js: 55 },\n  { name: \"张三\", js: 78 },\n];\nlet t = 0;\nconst resust = user.reduce((pre, cur, index, arr) => {\n  console.log(cur); // 当前元素\n  console.log(index); // 下标\n  console.log(\"pre\", pre); // 上一个遍历的元素\n\n  return (pre += cur.js); // 返回值将作为pre参数\n}, 89);\n```\n\n\n\n\n\n# 迭代器\n\n数组中可以使用多种迭代器方法\n\n### keys\n\n通过迭代对象获取索引，可通过next()一步一步向下拿到全部索引并执行操作。\n\n```javascript\nconst hs = [\"花森\", \"huasen\"，\"猪琦\"];\nconst keys = hs.keys(); // 获得迭代器对象\nconsole.log(keys.next()); // {value: 0, done: false}\nconsole.log(keys.next()); // {value: 1, done: false}\n\n// 需要把上面两行console.log去掉，因为上面两行迭代器就已经遍历到最后了，所以影响输出效果。\nfor (const key of keys) {\n  console.log(key);\n}\n```\n\n### values\n\n通过迭代对象获取值，可通过next()一步一步向下拿到全部索引并执行操作。\n\n### entries\n\n返回数组所有键值对的迭代器，可以使用解构加for-of循环获取数据。\n\n```javascript\nconst arr = [\"a\", \"b\", \"c\", \"花森\"];\nfor (const [key, value] of arr.entries()) {\n  console.log(key, value);\n}\n```\n\n\n\n\n\n# Symbol\n\nSymbol 的值是唯一的数据类型，防止使用属性名冲突而产生，比如向第三方对象中添加属性就有可能产生变量名冲突，而且Symbol不可以添加属性。\n\n### 1.变量声明\n\n```javascript\nlet hs = Symbol();\nlet edu = Symbol(\"传入描述Symbol的字符串，有利于分辨Symbol！\");\nconsole.log(hs); // symbol\nconsole.log(edu); // Symbol(传入描述Symbol的字符串，有利于分辨Symbol！)\nconsole.log(edu.description) // 获取描述\nconsole.log(hs == edu); //false\n```\n\n### 2.查找Symbol.for\n\n根据描述获取到唯一Symbol变量，如果不存则新建一个Symbol对象，使用`Symbol.for`会被系统登记，而使用Symbol不会被系统登记。\n\n```javascript\nlet hs = Symbol.for(\"传入描述Symbol的字符串，有利于分辨Symbol！\");\nlet edu = Symbol.for(\"传入描述Symbol的字符串，有利于分辨Symbol！\");\nconsole.log(hs == edu); // true\n```\n\n### 3.登记记录Symbol.keyFor\n\n返回Symbol登记的描述，如果没有找到则返回undefined\n\n```javascript\nlet hs = Symbol.for(\"花森\");\nconsole.log(Symbol.keyFor(hs)); //花森\n```\n\n### 4.操作要点\n\nSymbol可以保证对象属性的唯一，Symbol的声明和访问使用[]的形式进行操作，不能使用`.`操作符，因为点是操作字符串属性的写法。\n\n```javascript\nlet symbol = Symbol(\"花森\");\nlet obj = {\n  [symbol]: \"huasenjio\"\n};\nconsole.log(obj[symbol]); //huasenjio\n```\n\n### 5.实例操作\n\n#### <u>覆盖耦合</u>\n\n通过Symbol作为键值，每一个Symbol均是唯一，所以存入数据不会因为key值相同造成覆盖的可能。\n\n```javascript\nclass Cache {\n  static data = {};\n  static set(name, value) {\n    this.data[name] = value;\n  }\n  static get(name) {\n    return this.data[name];\n  }\n  }\n\n  let user = {\n    name: \"花森\",\n    key: Symbol(\"343434\"),\n  };\n\n  let cart = {\n    name: \"猪琦\",\n    key: Symbol(\"121212\"),\n  };\n  Cache.set(user.key, user);\n  Cache.set(cart.key, cart);\n  console.log(Cache.get(user.key));\n  console.log(Cache.data);\n```\n\n#### <u>遍历属性</u>\n\nSymbol 不能使用 `for/in和for/of` 遍历操作，遍历时Symbol属性默认被忽略，但是可以通过`Object.getOwnPropertySymbols`，遍历到对象中的所有Symbol属性。\n\n```javascript\nlet symbol = Symbol(\"导航\");\nlet user = {\n  name: \"花森\",\n  [symbol]: \"huasenjio\",\n};\n\nfor (const key of Object.getOwnPropertySymbols(user)) {\n  console.log(key);\n}\nlet symbol = Symbol(\"导航\");\nlet user = {\n  name: \"花森\",\n  [symbol]: \"huasenjio\",\n};\n\nfor (const key of Object.getOwnPropertySymbols(user)) {\n  console.log(key);\n}\n```\n\n#### <u>变量保护</u>\n\n使用symbol作为属性名，起到变量保护的作用，无法被遍历访问到，可以通过对外开辟函数的方式去访问。\n\n```javascript\nconst site = Symbol(\"网站名称\");\nclass User {\n  constructor(name) {\n    this[site] = \"森酱\";\n    this[name] = name;\n  }\n  getName() {\n    return `${this[site]}-${this.name}`;\n  }\n}\nconst hs = new User(\"hs\");\nconsole.log(hs.getName());\nconsole.log(hs.site); // 无法访问到森酱\nfor (const key in hs) {\n  console.log(key);\n}\n```\n\n\n\n\n\n# Set\n\n无论是基本类型还是对象引用，都不能存入重复的元素，只可以保存值而没有键名；严格类型检测入字符串不等于数值型数字，即元素唯一。\n\n### 1.变量声明\n\n使用数组作为初始化的数据，如果存在多个相同值则仅会保存第一个值，其余的全部忽略。\n\n```javascript\nlet hs = new Set([\"花森\", \"hs\", \"1\", 1]); \nconsole.log(hs.values()); //{\"花森\", \"hs\", \"1\" ,1}\n```\n\n### 2.常用操作\n\n#### <u>add添加元素</u>\n\n```javascript\nlet hs = new Set();\n\nhs.add('huasen');\n```\n\n#### <u>size获取数量</u>\n\n```javascript\nlet hs = new Set(['huasen', '花森']);\nconsole.log(hs.size); //2\n```\n\n#### <u>has检测元素</u>\n\n```javascript\nlet hs = new Set(['huasen', '花森']);\nconsole.log(hs.has(\"花森\")); // true\n```\n\n#### <u>delete删除</u>\n\n```javascript\nconsole.log(hs.delete(\"hdcms\")); //true\n```\n\n#### <u>clear清空元素</u>\n\n```javascript\nhs.clear();\n```\n\n### 3.数组转换\n\n```javascript\nconst set = new Set([\"hs\", \"花森\"]);\nconsole.log([...set]) // 点语法\nconsole.log(Array.from(set)); // array.from\n```\n\n### 4.去重\n\n```javascript\nconsole.log([...new Set([1,2,3,3,3,4])];//[1,2,3,4]\nconsole.log([...new Set(\"hhssjjoo\")].join(\"\"));//hsjo\n```\n\n### 5.遍历数据\n\n```javascript\nlet arr = [7, 6, 2, 8, 2, 6];\nlet set = new Set(arr);\n//使用forEach遍历\nset.forEach((item,key) => console.log(item,key)); // item 和 value一致\n\n//使用for-of\nfor (const iterator of set) {\n\tconsole.log(iterator);\n}\n```\n\n### 6.交集\n\n通过数组的过滤函数filter和has查询\n\n```javascript\nlet hs = new Set([\"1\", \"8\"]);\nlet zhuqi = new Set([\"2\", \"8\"]);\nlet newSet = new Set([...hs].filter((item) => zhuqi.has(item))); // 返回zhuqi数据中也有的数\nconsole.log(newSet); //{\"8\"}\n```\n\n### 7.差集\n\n```javascript\nlet hs = new Set([\"1\", \"8\"]);\nlet zhuqi = new Set([\"2\", \"8\"]);\nlet newSet = new Set([...hs].filter((item) => !zhuqi.has(item))); // 返回zhuqi数据中没有的数\nconsole.log(newSet); \n```\n\n### 8.交集\n\n```javascript\nlet hs = new Set([\"1\", \"8\"]);\nlet zhuqi = new Set([\"2\", \"8\"]);\nlet newSet = new Set([...hs,...zhuqi]); // 返回zhuqi数据中没有的数\nconsole.log(newSet); \n```\n\n### 9.WeakSet\n\nWeakSet结构同样不会存储重复的值，储存的元素必须是对象类型，垃圾回收机制不考虑WeakSet，当一个变量被引用时，内存中会有一个引用计数器会进行加一，但对于weakset引用，计数器不会加一，所以weakset不管是否在使用变量都均会被删除，是属于弱引用的范畴，weakset没有keys（），values（），entries（）和size等方法，且不能被遍历！\n\n#### <u>声明</u>\n\n```javascript\nnew WeakSet([\"hs\", \"zhuqi\"]); //Invalid value used in weak set\n\nnew WeakSet(\"hdcms\"); //Invalid value used in weak set \n\nnew WeakSet([{ name: \"huasen\" }]); //正确\n```\n\n#### <u>基本操作</u>\n\n```javascript\nconst hs = new WeakSet();\nconst arr = [\"hdcms\"];\n\n//添加操作\nhd.add(arr);\nconsole.log(hs.has(arr));\n\n//删除操作\nhd.delete(arr);\n\n//检索判断\nconsole.log(hs.has(arr));\n```\n\n\n\n\n\n# Map\n\nMap是一组键值对的结构，用于解决以往不能用对象做为键的问题，具有极快的查找速度，函数、对象、基本数据类型均可以作为键和值。其中键是对象则保存的是内存地址，如果值相同但内存地址不同也会被视为两个键值对。\n\n### 1.声明定义\n\n可以接受数组作为参数，该数组的成员是一个表示键值对的数组。\n\n```javascript\nlet m = new Map([\n  [\"h\", \"花\"],\n  [\"s\", \"森\"],\n]);\n\nconsole.log(m.get(\"h\")); //花\n```\n\n### 2.基本操作\n\n```javascript\nlet m = new Map([\n  [\"h\", \"花\"],\n  [\"s\", \"森\"],\n]);\n// 获取键值对的数量\nconsole.log(m.size);\n\n// 读取元素\nconsole.log(m.get(\"h\")); //花\n\n// 删除元素\nconsole.log(m.delete(\"h\")); //花\n\n// 清空map\nconsole.log(map.clear());\n\n```\n\n### 3.遍历数据\n\n可以使用`keys/values` 函数遍历键与值\n\n```javascript\nlet hs = new Map([[\"h\", \"花\"], [\"s\", \"森\"]]);\nfor (const key of hs.keys()) {\n  console.log(key);\n}\nfor (const value of hs.values()) {\n  console.log(value);\n}\n```\n\n### 4.数组转换\n\n1. [...map];\n2. Array.from(map);\n\n### 5.WeabMap\n\n详细请参考WeabSet的用法\n\n\n\n\n\n# 函数进阶\n\n函数是将复用的代码块封装起来的模块，js中的函数也是对象，可以通过构造函数Function创建实例，全域定义的函数是属于window对象中，容易造成覆盖的问题，使用let/const定义的参数时不会压入window对象中。标准声明的函数优先级更高，解析器会优先执行提取放在代码树的顶端，所以同一作用域下函数声明的位置顺序不限制。\n\n### 1.声明定义\n\n```javascript\n// 构造函数的方式\nlet hs = new Function(\"title\", \"console.log(title)\");\nhd('花森酱');\n\n// 标准语法的方式\nfunction hs(num) {\n\treturn ++num;\n}\nconsole.log(hs(3));\n\n// es6的箭头函数\nlet huasen = () => {\n  \n}\n\n// 简写形式\nuser = {\n  setName() {\n    \n  }\n}\n```\n\n### 2.匿名函数\n\n匿名函数需要赋值给某一个变量，而且一定需要以`;`结尾，匿名函数的执行者是window对象即内部的this是指向window对象，严格模式下this指向undefined而不是window对象。\n\n```javascript\nlet hs = function () {\n  console.log(this); // window对象\n};\nhs();\n\n[].map(()=>{})\n```\n\n### 3.立即执行函数\n\n立即执行函数指函数定义时立即执行，可以定义私有作用域防止污染全局作用域。\n\n```javascript\n\"use strict\";\n(function () {\n    var web = 'hs';\n})();\nconsole.log(web); //web is not defined\n```\n\n### 4.函数参数\n\n#### <u>形参实参</u>\n\n调用函数时传入的变量叫做实参，定义函数参数是的变量叫做形参。当形参的数量大于实参时，没有被赋值的形参就被定义为undefined；实参的数量大于形参时，多余的实参将被忽略并且不会报错。\n\n```javascript\n// n1,n2 为形参\nfunction sum(n1, n2) {\n\treturn n1+n2;\n}\n\n// 参数 2,3 为实参\nconsole.log(sum(2, 3)); //5\n```\n\n#### <u>默认参数</u>\n\n通常为形参设置默认值\n\n```javascript\n// 无序考虑兼容\nfunction avg(total, year) {\n  year = year || 1; // 赋值\n  return Math.round(total / year);\n}\nconsole.log(avg(2000, 3));\n\n//es6写法需要考虑兼容性\nfunction avg(total, year = 1) {\n  return Math.round(total / year);\n}\nconsole.log(avg(2000, 3));\n```\n\n#### <u>回调函数</u>\n\n函数调用时可以传递函数参数，一般用于回调函数，执行调用的函数a时，默认执行传入的函数，这个场景叫做回调，传入的函数称为回调函数。\n\n```javascript\n// 箭头函数演示\n[].filter(()=> {})\n// 普通函数\n[].filter(function(){})\n```\n\n#### <u>argument</u>\n\narguments 是函数获得到所有参数集合，获得传入参数的集合。\n\n```javascript\n// 普通参数\nlet hs = function () {\n  console.log(arguments); // 函数参数\n};\nhs(1, 2, 3, 4);\n\n// 对参数进行求和\nfunction sum() {\n  return [...arguments].reduce((total, num) => {\n    return (total += num);\n  }, 0);\n}\nconsole.log(sum(2, 3, 4, 2, 6)); //17\n```\n\n### 5.递归调用\n\n递归指函数内部调用自身的方式，主要用于数量不确定的循环操作，必须有要结束循环的条件否则会陷入死循环，一般慎用递归调用，容易造成内存泄露的风险。\n\n```javascript\nfunction factorial(sum) {\n  if (sum <= 1) {\n    return sum;\n  } else {\n    return sum * factorial(--sum);\n  }\n}\nconsole.log(factorial(4));\n```\n\n### 6.标签函数\n\n```javascript\nfunction hd(str, ...values) {\n  console.log(str); //[\"站点\", \"-\", \"\", raw: Array(3)]\n  console.log(values); //[\"花森\", \"huasenjio.top]\n}\nlet name = \"花森\",\n    url = \"huasenjio.top\";\nhd`站点${name}-${url}`;\n```\n\n\n\n\n\n# 作用域\n\n作用域链只向上查找，找到全局window即终止。当在每一个对象中引用了一个变量是，如果挡墙作用域不存在就往上级作用域查找，`[].toString()`，可以调用输出字符串，细心的小伙伴可能发现，数组的原型根本没有toString方法，但是Object上面存在toString方法。所以查找toString变量的顺序是先去找数组的原型，再去找在Object上的原型，直到window全局，如果还没有找到则报错。\n\n```javascript\nconsole.log(name); // 直接这样输出并不会报错因为window上默认存在name属性且为空\nconsole.log(n); // n is not defined 因为window上面没有n属性\n```\n\n\n\n\n\n# 对象\n\n面向对象程序设计成为OOP，对象是属性和方法的集合体，内部的复杂逻辑代码被隐藏，仅仅暴露少量代码给外界，更改对象内部的复杂逻辑不会对外部造成影响和抽象，继承是通过代码复用减少冗余，根据不同形态的对象产生不同的结果称之为多态。\n\n### 1.声明定义\n\n```javascript\nlet obj = {\n  name: 'huasen',\n  get:function() {\n  \treturn this.name;\n  }\n}\nconsole.log(obj.get()); //huasen\n```\n\n### 2.属性管理\n\n#### <u>基本操作</u>\n\n```javascript\nlet user = {\n  name: \"huasen\",\n  [\"my-title\"]: \"花森导航\",\n};\nconsole.log(user.name); // 使用点语法\nconsole.log(user[\"name\"]); // 使用数组形式\nconsole.log(user[\"my-title\"]); // 如果属性名不是合法变量就必须使用括号的形式\n\n// 添加属性\nuser.a = \"A\" // 使用点语法\nuser[\"b\"] = \"B\" // 使用数组形式\n\n// 删除属性\ndelete user.name;\n```\n\n#### <u>检测属性</u>\n\n1）`hasOwnProperty`检测对象自身是否包含指定的属性，不检测原型链上继承的属性。\n\n```javascript\nlet obj = { name: '花森'};\nconsole.log(obj.hasOwnProperty('name')); //true\n```\n\n2）使用 `in` 可以在原型对象上检测。\n\n```javascript\nlet obj = {name: \"花森\"};\nlet hs = {\n  web: \"huasenjio\"\n};\n\n//设置hs为obj的新原型\nObject.setPrototypeOf(obj, hs);\nconsole.log(obj);\n\nconsole.log(\"web\" in obj); //true 说明web属性在obj的原型链上\nconsole.log(obj.hasOwnProperty(\"web\")); //false\n```\n\n#### <u>assign属性合并</u>\n\n使用Object.assign静态方法进行从一个或多个对象复制属性，并将属性合并，但是是浅拷贝。\n\n```javascript\n\"use strict\";\nlet hs = { a: 1, b: 2 };\nhd = Object.assign(hs, { f: 1 }, { m: 9 });\nconsole.log(hs); //{a: 1, b: 2, f: 1, m: 9}\n```\n\n#### <u>动态属性</u>\n\n对象属性可以通过表达式计算定义，动态设置属性或者执行方法时很美妙。\n\n```javascript\nlet id = 0;\nconst user = {\n  [`id-${id++}`]: id,\n  [`id-${id++}`]: id,\n  [`id-${id++}`]: id\n};\nconsole.log(user);\n```\n\n### 3.引用特性\n\n对象和函数一样是引用数据类型，赋值操作相当于复制并赋予地址，其实还是引用同一块内存地址。\n\n```javascript\nlet user = {\n  name: \"huasen\",\n  [\"tit-le\"]: \"花森导航\",\n};\nlet per = user;\nconsole.log(per);\nper.name = \"猪琦\";\nconsole.log(user); // user中也被修改了\n\n// 函数参数同样也是赋值地址\n(function () {\n  arguments[0][\"tit-le\"] = \"笔录\";\n})(user);\n```\n\n### 4.对象转换\n\n对象直接参与计算时，系统根据计算的场景在`string、number、default`之间转换。如果场景需要字符串类型，则对象执行toString()后执行valueOf获取到字符串，如果需要字符串型，先执行valueOf获得数值后执行toString获得字符串。\n\n```javascript\nlet hs = {\n  name: \"花森\",\n  num: 1,\n  valueOf: function () {\n    console.log(\"valueOf\");\n    return this.num;\n  },\n  toString: function () {\n    console.log(\"toString\");\n    return this.name;\n  },\n};\nconsole.log(hs + 3); //valueOf 4\nconsole.log(`${hs}导航`); //toString 花森导航\n```\n\n### 5.解构赋值\n\n解构是一种更简洁的赋值特性，可以理解为分解一个数据的结构，用法与数组的解构相似，建议解构使用`var/let/const`声明，否则严格模式下会报错。\n\n```javascript\n// 对象的解构\nlet info = {name:'花森',url:'huasenjio'};\nlet {name:n,url:u} = info // 重新定义变量名为n u\nconsole.log(n); \n\n// 如果属性名与变量相同可以省略属性定义\nlet {name:n,url:u} = {name:'花森',url:'huasenjio'};\n\n// 函数返回值解构到变量\nfunction hs() {\n  return {\n    name: '花森',\n    url: 'huasenjio'\n  };\n}\nlet {name: n,url: u} = hs();\nconsole.log(n);\n\n// 函数传参\n\"use strict\";\nfunction hd({ name, age }) {\n  console.log(name, age); //花森 18\n}\nhd({ name: \"花森\", age: 18 });\n```\n\n### 6.默认值\n\n```javascript\nlet [name, site = '花森'] = ['hs'];\nconsole.log(site); //花森\n```\n\n### 7.遍历对象\n\n#### <u>keys/values/entries</u>\n\n```javascript\nconst hs = {\n  name: \"花森\",\n  age: 10\n};\nconsole.log(Object.keys(hs)); //[\"name\", \"age\"] 获取对象属性名组成的迭代器\nconsole.log(Object.values(hs)); //[\"花森\", 10] 获取对象属性组成的迭代器\nconsole.table(Object.entries(hs)); //[[\"name\",\"花森\"],[\"age\",10]] 两个迭代器\n```\n\n#### <u>for/of遍历迭代器</u>\n\nFor-of是不可以直接遍历对象，它是用于遍历迭代对象。\n\n```javascript\nconst hd = {\n  name: \"后盾人\",\n  age: 10\n};\nfor (const key of Object.keys(hd)) {\n  console.log(key);\n}\n```\n\n### 8.拷贝对象\n\n#### <u>浅拷贝</u>\n\n```javascript\n// for-in的方式遍历对象进行浅拷贝\nlet obj = {name: \"花森\"};\n\nlet hs = {};\nfor (const key in obj) {\n  hs[key] = obj[key];\n}\nhs.name = \"huasen\";\nconsole.log(hs);\nconsole.log(obj);\n\n// Object.assign进行简单的浅拷贝但同名属性将会被覆盖\nObject.assign(hs, obj);\nhs.name = \"huasen\";\nconsole.log(hs);\nconsole.log(obj);\n\n// 展开语法\nlet hs = { ...obj };\n```\n\n#### <u>深拷贝</u>\n\n浅拷贝不会将深层的数据复制，深拷贝完全就是复制出一个新的对象，两个对象完全独立。\n\n```javascript\nlet obj = {\n  name: \"花森\",\n  user: {\n    name: \"hs\",\n  },\n  data: [],\n};\n\nfunction copy(object) {\n  let obj = object instanceof Array ? [] : {}; // 判断是数组或者对象进行声明变量\n  // 解构获得键值对\n  for (const [k, v] of Object.entries(object)) {\n    obj[k] = typeof v == \"object\" ? copy(v) : v; // 如果当前属性是引用类型则递归调用，基础数据类型则直接赋值。\n  }\n  return obj; // 返还对象\n}\n\nlet huasen = copy(obj);\nhuasen.data.push(\"zhuqi\");\nconsole.log(JSON.stringify(huasen, null, 2));\nconsole.log(JSON.stringify(obj, null, 2));\n```\n\n### 9.构造函数\n\n#### <u>工厂模式</u>\n\n普通函数中返还一个相同结构的对象，修改工厂模式的方法会影响所有的同类对象，且声明不需要new关键词。\n\n```javascript\nfunction stu(name) {\n  return {\n    name,\n    show() {\n      console.log(this.name); // this代表函数调用者\n    }\n  };\n}\nconst lisi = stu(\"李四\");\nlisi.show();\nconst hs = stu(\"huasen\");\nhs.show();\n```\n\n#### <u>构造函数</u>\n\n构造函数的函数名首字母需要大写的命名规范，this指向当前创建的对象，系统会自动返回this关键词，但也可以收到return返回，手动返回必须是对象，不然setter方法会屏蔽且需要new关键词生成对象。\n\n```javascript\nfunction Student(name) {\n  this.name = name;\n  this.show = function() {\n    console.log(this.name);\n  };\n  // return this; // 系统会自动返回\n}\nconst lisi = new Student(\"李四\");\nlisi.show();\nconst xj = new Student(\"王五\");\nwangwu.show();\n```\n\n### 10.属性特征\n\n#### <u>查看特征</u>\n\n使用 `Object.getOwnPropertyDescriptor`查看对象属性的描述\n\n```javascript\nlet obj = {\n  name: \"花森\",\n  user: {\n    name: \"hs\",\n  },\n  data: [],\n};\nconsole.log(\n  JSON.stringify(Object.getOwnPropertyDescriptor(obj, \"name\"), null, 2)\n);\n// {\n//   \"value\": \"花森\",\n//   \"writable\": true,\n//   \"enumerable\": true,\n//   \"configurable\": true\n```\n\n| 特性         | 说明                                                 | 默认值    |\n| ------------ | ---------------------------------------------------- | --------- |\n| configurable | 能否使用delete 能否需改属性特性 或能否修改访问器属性 | true      |\n| enumerable   | 对象属性是否可通过for-in循环或Object.keys() 读取     | true      |\n| writable     | 对象属性是否可修改                                   | true      |\n| value        | 对象属性的默认值                                     | undefined |\n\n#### <u>设置属性</u>\n\n使用`Object.defineProperty` 方法修改属性特性\n\n```javascript\n// 禁止遍历修改删除\n\"use strict\";\nconst user = {\n  name: \"花森\",\n  age: 18\n};\nObject.defineProperty(user, \"name\", {\n  value: \"花森\",\n  writable: false,\n  enumerable: false,\n  configurable: false\n});\n\n// 一次性修改多个属性\nObject.defineProperty(user, {\n  name: {value: \"花森\", writable: false},\n  age: {value: 18,enumerable: false}\n});\n```\n\n#### <u>禁止添加</u>\n\n`Object.preventExtensions` 禁止向对象添加属性，`Object.isExtensible(user)`可以判断是否可以向属性中添加属性。\n\n```javascript\n\"use strict\";\nconst user = {\n  name: \"花森\"\n};\nObject.preventExtensions(user);\nuser.age = 18; //Error\n```\n\n#### <u>封闭对象</u>\n\nObject.seal()`方法封闭一个对象，阻止添加新属性并将所有现有属性标记为 `configurable: false，可以通过`isSealed`检测是否发生封闭。\n\n#### <u>冻结对象</u>\n\n`Object.free`za 冻结的对象不允许添加、删除、修改、writable、configurable都会被标记为`false`。\n\n```javascript\n\"use strict\";\nconst user = {\n  name: \"花森\"\n};\nObject.freeze(user);\nuser.name = \"花森\"; //Error\n```\n\n### 12.属性访问器\n\ngetter方法用于获得属性值，setter方法用于设置属性，这是JS提供的存取器特性即使用函数来管理属性。用于避免错误的赋值，需要动态检测值的改变。属性只能在访问器和普通属性选择一个，不能共同存在。\n\n#### <u>getter/setter</u>\n\n```javascript\n\"use strict\";\nconst user = {\n  data: { name: \"花森\", age: null },\n  set age(value) {\n    if (typeof value != \"number\" || value > 100 || value < 10) {\n      throw new Error(\"年龄格式错误\");\n    }\n    this.data.age = value;\n  },\n  get age() {\n    return `年龄: ${this.data.age}`;\n  },\n};\nuser.age = 18; // 不能随便赋值\nconsole.log(user.age);\n```\n\n#### <u>内部私有属性</u>\n\n```javascript\n\"use strict\";\nconst user = {\n  get name() {\n    return this._name;\n  },\n  set name(value) {\n    if (value.length <= 3) {\n      throw new Error(\"用户名不能小于三位\");\n    }\n    this._name = value;\n  },\n};\nuser.name = \"花森酱酱\";\nconsole.log(user.name);\n```\n\n#### <u>访问器描述符</u>\n\n使用 `defineProperty` 定义私有属性\n\n```javascript\n// 函数写法\nfunction User(name, age) {\n  let data = { name, age };\n  Object.defineProperties(this, {\n    name: {\n      get() {\n        return data.name;\n      },\n      set(value) {\n        if (value.trim() == \"\") throw new Error(\"无效的用户名\");\n        data.name = value;\n      }\n    },\n    age: {\n      get() {\n        return data.name;\n      },\n      set(value) {\n        if (value.trim() == \"\") throw new Error(\"无效的用户名\");\n        data.name = value;\n      }\n    }\n  });\n}\n\n// class语法糖写法\n\"use strict\";\nconst DATA = Symbol();\nclass User {\n  constructor(name, age) {\n    this[DATA] = { name, age };\n  }\n  get name() {\n    return this[DATA].name;\n  }\n  set name(value) {\n    if (value.trim() == \"\") throw new Error(\"无效的用户名\");\n    this[DATA].name = value;\n  }\n  get age() {\n    return this[DATA].name;\n  }\n  set age(value) {\n    if (value.trim() == \"\") throw new Error(\"无效的用户名\");\n    this[DATA].name = value;\n  }\n}\n\n// 测试代码\nlet hs = new User(\"花森\", 18);\nconsole.log(hs.name);\nhs.name = \"huasen\";\nconsole.log(hs.name);\nconsole.log(hs);\n```\n\n### 13.代理拦截\n\n代理（拦截器）是整个对象的访问控制，`setter/getter` 是对单个对象属性的控制，而代理是对整个对象的控制。\n\n1. 读写属性时代码更简洁；\n2. 对象的多个属性控制统一交给代理完成；\n3. 严格模式下set必须返回布尔值；\n\n```javascript\nlet user = {\n  data: { name: \"花森\", sex: 18 },\n  title: \"函数代理\",\n};\n\n(\"use strict\");\n// 为对象建立代理\nconst proxy = new Proxy(user, {\n  get(obj, property) {\n    console.log(\"getter方法执行了\");\n    return obj[property];\n  },\n  set(obj, property, value) {\n    console.log(\"setter方法执行了\");\n    obj[property] = value;\n    return true;\n  },\n});\n// 使用代理修改属性\nproxy.age = 10;\n// 使用代理获得属性\nconsole.log(proxy.name);\n```\n\n### 14.JSON\n\njson是广泛运用前后端数据交换的格式，具有轻量级且易于阅读和编写的特点。\n\n1. json是数据格式替换xml的最佳方式；\n2. 前后端交互数据的主要格式；\n3. json标准中要求双引号包裹属性；\n\n```json\nlet lessons = [\n  {\n    \"title\": '媒体查询',\n    \"category\": 'css',\n    \"click\": 199\n  },\n  {\n    \"title\": 'FLEX',\n    \"category\": 'css',\n    \"click\": 12\n  },\n  {\n    \"title\": 'MYSQL',\n    \"category\": 'mysql',\n    \"click\": 89\n  }\n];\n\nconsole.log(lessons[0].title);\n\n```\n\n#### <u>序列化</u>\n\n序列化是将 `json` 转换为字符串，一般用来向其他语言传输使用。\n\n```json\nlet lessons = [\n  {\n    \"title\": '媒体查询',\n    \"category\": 'css',\n    \"click\": 199\n  },\n  {\n    \"title\": 'FLEX',\n    \"category\": 'css',\n    \"click\": 12\n  },\n  {\n    \"title\": 'MYSQL',\n    \"category\": 'mysql',\n    \"click\": 89\n  }\n];\n// 使用JSON字符串序列化\nconsole.log(JSON.stringify(lessons)); // 值 属性 tab数\n```\n\n#### <u>反序列化</u>\n\n使用 `JSON.parse` 将字符串 `json` 解析成对象\n\n```javascript\nconsole.log(JSON.parse(jsonStr));\n```\n\n\n\n\n\n# 事件\n\n文档、浏览器、标签元素等元素在特定状态下触发的行为即为事件，JS为不同的事件定义的类型，事件目标是指产生事件的对象，事件具有冒泡捕获的特性，一个行为可能会造成多个事件的触发，处理事件的一段代码称为处理程序。\n\n### 1.事件绑定\n\n#### <u>html中绑定</u>\n\n可以在html元素上设置事件处理程序，浏览器解析后会绑定到DOM属性中。\n\n```html\n<button onclick=\"alert(`huasen`)\">huasen</button>\n```\n\n#### <u>dom绑定</u>\n\n可以将事件处理程序绑定到DOM属性中，使用setAttribute方法设置事件处理程序无效，属性名称区分大小写。\n\n```html\n<div id=\"app\">huasen</div>\n<script>\n  const app = document.querySelector('#app')\n  app.onclick = function () {\n    this.style.color = 'red'\n  }\n</script>\n```\n\n#### <u>事件监听</u>\n\n建议使用新的事件监听绑定方式，`transtionend / DOMContentLoaded` 等事件类型只能使用事件监听addEventListener 处理，同一个事件类型设置多个事件处理程序则会按顺序先后执行，同样可以给为添加元素添加事件。具有以下参数方法：\n\n1）参数一，事件类型；\n\n2）参数二，事件处理程序；\n\n3）参数三，制定的选项，once仅执行一次，capture：true/false捕获阶段，passive：true永远不调用`preventDefault()`阻值默认行为；\n\n| 方法                | 说明             |\n| ------------------- | ---------------- |\n| addEventListener    | 添加事件处理程序 |\n| removeEventListener | 移除事件处理程序 |\n\n### 2.事件对象\n\n执行事件处理程序时，会产生当前事件相关信息的对象，即为事件对事。系统会自动做为参数传递给事件处理程序，事件对象常用属性如下：\n\n| 属性               | 说明                                                         |\n| ------------------ | ------------------------------------------------------------ |\n| type               | 事件类型                                                     |\n| target             | 事件目标对象 冒泡的父级通过该属性可以找到在哪个元素上执行了事件 |\n| currentTarget      | 当前执行事件的对象                                           |\n| timeStamp          | 事件发生时间                                                 |\n| x                  | 相对窗口的X坐标                                              |\n| y                  | 相对窗口的Y坐标                                              |\n| clientX            | 相对窗口的X坐标                                              |\n| clientY            | 相对窗口的Y坐标                                              |\n| screenX            | 相对计算机屏幕的X坐标                                        |\n| screenY            | 相对计算机屏幕的Y坐标                                        |\n| pageX              | 相对于文档的X坐标                                            |\n| pageY              | 相对于文档的Y坐标                                            |\n| offsetX            | 相对于事件对象的X坐标                                        |\n| offsetY            | 相对于事件对象的Y坐标                                        |\n| layerX             | 相对于父级定位的X坐标                                        |\n| layerY             | 相对于父级定位的Y坐标                                        |\n| path               | 冒泡的路径                                                   |\n| altKey             | 是否按了alt键                                                |\n| shiftKey           | 是否按了shift键                                              |\n| metaKey            | 是否按了媒体键                                               |\n| window.pageXOffset | 文档参考窗口水平滚动的距离                                   |\n| window.pageYOffset | 文档参考窗口垂直滚动的距离                                   |\n\n### 3.冒泡捕获\n\n#### <u>冒泡行为</u>\n\n标签元素是嵌套的，在一个元素上触发的事件，同时也会向上执行父级元素的事件处理程序，一直到HTML标签元素。大部分事件都有冒泡特性，但像focus事件则不会发生冒泡。\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>测试</title>\n    <style>\n      #app {\n        background: #34495e;\n        width: 300px;\n        padding: 30px;\n      }\n      #app h2 {\n        background-color: #f1c40f;\n        margin-right: -100px;\n      }\n    </style>\n  </head>\n  <body>\n    <div id=\"app\">\n      <h2>花森酱</h2>\n    </div>\n    <script>\n      const app = document.querySelector(\"#app\");\n      const h2 = document.querySelector(\"h2\");\n      app.addEventListener(\"click\", (event) => {\n        console.log(`执行事件的节点:${event.currentTarget.nodeName}`);\n        console.log(`触发节点:${event.target.nodeName}`);\n      });\n      h2.addEventListener(\"click\", () => {\n        console.log(`执行事件的节点:${event.currentTarget.nodeName}`);\n        console.log(`触发节点:${event.target.nodeName}`);\n      });\n    </script>\n  </body>\n</html>\n```\n\n#### <u>阻止冒泡</u>\n\n冒泡过程中的任何事件处理程序中，都可以执行 `event.stopPropagation()` 方法阻止继续进行冒泡传递，仅会阻止当前代码段的程序，但可以通过`event.stopImmediatePropagation()`阻止相同事件的冒泡行为。\n\n#### <u>事件捕获</u>\n\n事件执行顺序为 捕获 > 事件目标 > 冒泡阶段执行，在向下传递到目标对象的过程即为事件捕获，通过设置第三个参数为true或{ capture: true } 在捕获阶段执行事件处理程序。\n\n```html\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>测试</title>\n    <style>\n      #app {\n        background: #34495e;\n        width: 300px;\n        padding: 30px;\n      }\n      #app h2 {\n        background-color: #f1c40f;\n        margin-right: -100px;\n      }\n    </style>\n  </head>\n  <body>\n    <div id=\"app\">\n      <h2>\n        huasenjio\n        <span>花森</span>\n      </h2>\n    </div>\n    <script>\n      const app = document.querySelector(\"#app\");\n      const h2 = document.querySelector(\"h2\");\n      const span = document.querySelector(\"span\");\n      app.addEventListener(\n        \"click\",\n        (event) => {\n          console.log(\"底部  事件\");\n        },\n        { capture: true }\n      );\n      h2.addEventListener(\"click\", (event) => {\n        console.log(\"中间  事件\");\n      });\n      span.addEventListener(\"click\", (event) => {\n        console.log(\"上面  事件\");\n      });\n    </script>\n  </body>\n</html>\n\n```\n\n#### <u>事件委托</u>\n\n借助冒泡思路，我们可以不为子元素设置事件，而将事件设置在父级。然后通过父级事件对象的event.target查找子元素，并对他做出处理，此过程叫做事件委托。\n\n```javascript\n<ul>\n  <li data-action=\"hidden\">花森导航</li>\n  <li data-action=\"color\" data-color=\"red\">笔录</li>\n  </ul>\n  <script>\n    class HS {\n      constructor(el) {\n        el.addEventListener(\"click\", (e) => {\n          const action = e.target.dataset.action;\n          this[action](e);\n        });\n      }\n      hidden() {\n        event.target.hidden = true;\n      }\n      color() {\n        event.target.style.color = event.target.dataset.color;\n      }\n    }\n  new HS(document.querySelector(\"ul\"));\n</script>\n```\n\n### 4.默认行为\n\nJS会有些对象会设置默认事件处理程序，比如A链接在点击时会进行跳转。一般默认处理程序会在用户定义的处理程序后执行，所以我们可以在我们定义的事件处理程序员取消默认事件处理程序的执行。使用onclick绑定的时间处理程序，return false就可以阻止默认行为，推荐`event.preventDefault() `进行阻止默认行为。\n\n```html\n<a href=\"http://n.huasenjio.top\">花森笔录</a>\n<script>\n  document.querySelector('a').addEventListener('click', () => {\n    event.preventDefault()\n    alert(event.target.innerText)\n  })\n</script>\n```\n\n### 5.窗口文档\n\n| 事件名              | 说明                                                         |\n| ------------------- | ------------------------------------------------------------ |\n| window.onload       | 文档解析及外部资源加载后                                     |\n| DOMContentLoaded    | 文档解析后不需要等待外部资源加载完毕就执行（只能使用addEventListener设置） |\n| window.beforeunload | 文档刷新或关闭时                                             |\n| window.unload       | 文档卸载时                                                   |\n| scroll              | 页面滚动时                                                   |\n\n### 6.鼠标事件\n\n针对鼠标操作的行为有多种事件类型，鼠标事件会触发在Z-INDEX最高的那个元素，仅能在顶层元素触发事件，被盖住的元素是无法触发点击事件。\n\n| 事件名      | 说明                                                    |\n| ----------- | ------------------------------------------------------- |\n| click       | 鼠标单击事件 同时顺序触发 mousedown/mouseup/click       |\n| dblclick    | 鼠标双击事件                                            |\n| contextmenu | 点击右键后显示的所在环境的菜单                          |\n| mousedown   | 鼠标按下                                                |\n| mouseup     | 鼠标抬起时                                              |\n| mousemove   | 鼠标移动时                                              |\n| mouseover   | 鼠标移动时                                              |\n| mouseout    | 鼠标从元素上离开时                                      |\n| mouseup     | 鼠标抬起时                                              |\n| mouseenter  | 鼠标移入时触发 不产生冒泡行为                           |\n| mosueleave  | 鼠标移出时触发 不产生冒泡行为                           |\n| oncopy      | 复制内容时触发                                          |\n| scroll      | 元素滚动时 可以为元素设置overflow:auto;产生滚动条来测试 |\n\n#### <u>事件属性</u>\n\n| 属性          | 说明                                                         |\n| ------------- | ------------------------------------------------------------ |\n| which         | 执行mousedown/mouseup时 显示所按的键 1左键 2中键 3右键       |\n| clientX       | 相对窗口X坐标                                                |\n| clientY       | 相对窗口Y坐标                                                |\n| pageX         | 相对于文档的X坐标                                            |\n| pageY         | 相对于文档的Y坐标                                            |\n| offsetX       | 目标元素内部的X坐标                                          |\n| offsetY       | 目标元素内部的Y坐标                                          |\n| altKey        | 是否按了alt键                                                |\n| ctrlKey       | 是否按了ctlr键                                               |\n| shiftKey      | 是否按了shift键                                              |\n| metaKey       | 是否按了媒体键                                               |\n| relatedTarget | mouseover事件时从哪个元素来的 mouseout事件时指要移动到的元素 当无来源（在自身上移动）或移动到窗口外时值为null |\n\n### 7.键盘事件\n\n针对键盘输入操作的行为有多种事件类型\n\n| 事件名  | 说明                                             |\n| ------- | ------------------------------------------------ |\n| Keydown | 键盘按下时 一直按键不松开时keydown事件会重复触发 |\n| keyup   | 按键抬起时                                       |\n\n#### <u>事件属性</u>\n\n| 属性     | 说明                          |\n| -------- | ----------------------------- |\n| keyCode  | 返回键盘的ASCII字符数字       |\n| code     | 按键码                        |\n| key      | 按键的字符含义表示 大小写不同 |\n| altKey   | 是否按了alt键                 |\n| ctrlKey  | 是否按了ctlr键                |\n| shiftKey | 是否按了shift键               |\n| metaKey  | 是否按了媒体键                |\n\n### 8.表单事件\n\n下面是可以用在表单上的事件类型\n\n| 事件类型        | 说明                                                         |\n| --------------- | ------------------------------------------------------------ |\n| focus           | 获取焦点事件                                                 |\n| blur            | 失去焦点事件                                                 |\n| element.focus() | 让元素强制获取焦点                                           |\n| element.blur()  | 让元素失去焦点                                               |\n| change          | 文本框在内容发生改变并失去焦点时触发 select/checkbox/radio选项改变时触发事件 |\n| input           | 内容改变时触发 包括粘贴内容或语音输入内容都会触发事件        |\n| submit          | 提交表单                                                     |\n\n\n\n\n\n# 原型和继承\n\n每一个构造函数都存在prototype原型对象，通过new实例的对象会继承原型对象的方法属性，实例对象通过`__proto__`属性指向构造函数的prototype原型对象，所有的函数的原型默认是Object的实例对象，因为Object构造函数的原型上具有`toString/toValues/isPrototypeOf` 方法，所以每个对象都可以调用。当实例上不存在属性或者方法则将到原型上查找，原型对象包含constructor属性指向构造函数，对象包含`__proto__` 指向他的原型对象。\n\n![xwlPCoTHqOZWXj6](https://s2.loli.net/2022/05/19/xwlPCoTHqOZWXj6.png)\n\n\n\n### 1.Object.getPrototypeOf\n\n 用于获取一个对象的原型\n\n```javascript\nconsole.log(Object.getPrototypeOf(a));\n```\n\n### 2.Object.setPrototypeOf\n\n可以使用 `__proto__` 或 `Object.setPrototypeOf` 设置对象的原型\n\n```javascript\nfunction Person() {\n  this.getName = function() {\n    return this.name;\n  };\n}\nfunction User(name, age) {\n  this.name = name;\n  this.age = age;\n}\nlet lisi = new User(\"李四\", 12);\nObject.setPrototypeOf(lisi, new Person()); //将Person的一个实例对象作为lisi的原型\nconsole.log(lisi.getName()); //李四\n```\n\n### 3.原型检测\n\n#### <u>instanceof</u>\n\ninstanceof 检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上\n\n```javascript\nfunction A() {}\nfunction B() {}\nfunction C() {}\n\nconst c = new C();\nB.prototype = c;\nconst b = new B();\nA.prototype = b;\nconst a = new A();\n\nconsole.dir(a instanceof A); //true\nconsole.dir(a instanceof B); //true\nconsole.dir(a instanceof C); //true\nconsole.dir(b instanceof C); //true\nconsole.dir(c instanceof B); //false\n```\n\n#### <u>isPrototypeOf</u>\n\n使用`isPrototypeOf`检测一个对象是否是另一个对象的原型链中\n\n```javascript\nconst a = {};\nconst b = {};\nconst c = {};\n\nObject.setPrototypeOf(a, b);\nObject.setPrototypeOf(b, c);\n\nconsole.log(b.isPrototypeOf(a)); //true\nconsole.log(c.isPrototypeOf(a)); //true\nconsole.log(c.isPrototypeOf(b)); //true\n```\n\n### 4.属性遍历\n\n#### <u>in</u>\n\n使用`in` 检测原型链上是否存在属性，使用 `hasOwnProperty` 只检测当前对象是否存在属性。\n\n```javascript\nlet a = { url: \"huasen\" };\nlet b = { name: \"花森\" };\nObject.setPrototypeOf(a, b); // 将a设置为b的原型\nconsole.log(\"name\" in a); // true\nconsole.log(a.hasOwnProperty(\"name\")); // false\nconsole.log(a.hasOwnProperty(\"url\")); // false\n```\n\n#### <u>for-in</u>\n\n```javascript\nlet hs = { name: \"花森\" };\n// 以hs为原型创建huasen对象\nlet huasen = Object.create(hs, {\n  url: {\n    value: \"huasenjio\",\n    enumerable: true,\n  },\n});\nconsole.log(huasen);\nfor (const key in huasen) {\n  console.log(key);\n}\n```\n\n### 5.借用原型\n\n使用 `call` 或 `apply` 可以借用其他原型方法完成功能\n\n```javascript\nlet hs = {\n  data: [1, 2, 3, 4, 5],\n};\n// 借用Math上面的max方法\nconsole.log(Math.max.apply(null, hs.data));\n\nlet zhuqi = {\n  lessons: { js: 100, php: 78, node: 78, linux: 125 },\n};\n// Object.values()被返回可枚举属性值的对象\nconsole.log(Math.max.apply(zhuqi, Object.values(zhuqi.lessons)));\n```\n\n### 6.\\__proto__\n\n实例化对象上存在一个`__proto__`记录原型的信息，可以通过对象访问到原型的属性和方法，严格意义上讲`__proto__` 不是对象属性，可以理解为protortype的一个getter/setter实现，是一个非标准的定义，内部使用`getter/setter` 控制输入值，所以只允许对象或者null的赋值，建议使用 `Object.setPrototypeOf `和`Object.getProttoeypOf `替代` __proto__` 的使用。\n\n![IKV9E7YPvqons6O](https://s2.loli.net/2022/05/19/IKV9E7YPvqons6O.png)\n\n\n\n```javascript\nlisi.__proto__ = new Person();\n```\n\n### 7.继承与多态\n\n#### <u>实现继承</u>\n\n```javascript\n<script>\n  function Person() {}\n  Person.prototype.getName = function () {\n    console.log(\"parent method\");\n  };\n\n  function User() {}\n\n  // 方式一，全部实例对象实现继承，Object.create(Person.prototype)，建立一个a空对象且空对象的原型对象是Person的原型对象，User.prototype = a.__proto__ = Person.prototype。\n  User.prototype = Object.create(Person.prototype);\n  User.prototype.constructor = User;\n  // 原型对象的方法设置放在建立原型链之后，避免造成覆盖。\n  User.prototype.showUser = function () {\n    console.log(\"User的方法\");\n  };\n\n  console.log(new User());\n\n  // 方式二，对单个对象实现继承，设置lisi对象原型，等同于lisi.__proto__ = Person.prototype，同样会造成原型对象的constructor构造函数丢失。\n  // let lisi = new User();\n  // Object.setPrototypeOf(lisi, Person.prototype);\n  // console.dir(lisi);\n  // console.dir(new User());\n</script>\n```\n\n#### <u>继承</u>\n\n对象能使用它上游原型链上存在的方法和状态\n\n```javascript\n// Array原型对象上不存在valueOf方法，但是因为Array继承Object对象，即[]的__proto__指向的是Array的原型对象,而Array的__proto__指向的是Object的原型对象，因为Object的原型对象上存在valueOf方法，所以[]可以使用。\nconsole.log([]);\nconsole.log([1, 2, 3, 4].valueOf()); //  (4) [1, 2, 3, 4]\n```\n\n#### <u>方法重写</u>\n\n子类的定义与父类相同方法名的方法就可以重写父类的方法，思想就是不让子类顺着原型链网上找，因为它在自己的原型上查找到方法后就不会再向上查找，这一点与nodejs找依赖库的思想一致。\n\n```javascript\nfunction Person() {}\nPerson.prototype.getName = function() {\n  console.log(\"parent method\");\n};\n\nfunction User(name) {}\nUser.prototype = Object.create(Person.prototype);\nUser.prototype.constructor = User;\n\nUser.prototype.getName = function() {\n  //调用父级同名方法\n  Person.prototype.getName.call(this);\n  console.log(\"child method\");\n};\nlet hd = new User();\nhd.getName();\n```\n\n#### <u>多态</u>\n\n根据多种不同的形态产生不同的结果，下而会根据不同形态的对象得到了不同的结果。例如动物是猫和狗的父类，动物有会叫的方法，猫和狗实现动物叫的方法时表现形式不同。这就是多态。\n\n```javascript\nfunction User() {}\nUser.prototype.show = function() {\n  console.log(this.description());\n};\n\nfunction Admin() {}\nAdmin.prototype = Object.create(User.prototype);\nAdmin.prototype.description = function() {\n  return \"管理员在此\";\n};\n\nfunction Member() {}\nMember.prototype = Object.create(User.prototype);\nMember.prototype.description = function() {\n  return \"我是会员\";\n};\n\nfunction Enterprise() {}\nEnterprise.prototype = Object.create(User.prototype);\nEnterprise.prototype.description = function() {\n  return \"企业帐户\";\n};\n\nfor (const obj of [new Admin(), new Member(), new Enterprise()]) {\n  obj.show();\n}\n```\n\n### 8.继承进阶\n\n#### <u>构造函数</u>\n\n```javascript\nfunction User(name) {\n  this.name = name;\n  console.log(this); // Admin\n}\nUser.prototype.getUserName = function () {\n  return this.name;\n};\n\nfunction Admin(name) {\n  User.call(this, name); // 将User构造函数绑定给Admin\n}\nAdmin.prototype = Object.create(User.prototype);\n\nlet hs = new Admin(\"花森\");\nconsole.log(hs.getUserName()); //花森\n```\n\n#### <u>Mixin多继承</u>\n\n`JS`不能实现多继承，如果要使用多个类的方法时可以使用`mixin`混合模式来完成。mixin类是一个包含许多其他类方法的对象，经过Object.assign对象合并的方式为原型添加方法。\n\n```javascript\n<script>\n  function extend(sub, sup) {\n    sub.prototype = Object.create(sup.prototype);\n    sub.prototype.constructor = sub;\n  }\n  function User(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  User.prototype.show = function () {\n    console.log(this.name, this.age);\n  };\n  const Credit = {\n    total() {\n      console.log(\"统计积分\");\n    },\n  };\n  const Request = {\n    ajax() {\n      console.log(\"请求后台\");\n    },\n  };\n\n  function Admin(...args) {\n    User.apply(this, args);\n  }\n  extend(Admin, User);\n  Object.assign(Admin.prototype, Request, Credit);\n  let hs = new Admin(\"花森\", 19);\n  console.dir(hs);\n  hs.show();\n  hs.total(); //统计积分\n  hs.ajax(); //请求后台\n</script>\n```\n\n\n\n\n\n# class\n\n为了和其他语言的形态一致，JS提供了class关键词用于模拟传统的class，只是原型继承的语法糖形式，class为了让类的声明和继承更加简洁清晰，class默认使用严格模式执行。\n\n### 1.声明定义\n\n```javascript\n<script>\n  // 构造函数构造对象\n  function User(name) {\n    //实例对象属性\n    this.name = name;\n  }\n  //静态属性\n  User.type = \"用户\";\n  //静态方法\n  User.showTypea = function() {\n    // 静态方法调用的对象是构造函数 所以静态方法中仅可以使用静态属性\n    return this.type;\n  };\n  // 原型添加函数(所有实例对象可以访问)\n  User.prototype.showName = function() {\n    return this.name;\n  };\n  console.dir(User);\n  console.dir(new User(\"森哥哥\"));\n\n  // 类的方式构建对象 (extends继承对于构造函数是 Admin.__proto__ == User, 对于实例对象是 实例对象.__proto__ == User.prototype.)\n  class Admin extends User {\n    //静态属性\n    static type = \"管理员\";\n  constructor(name) {\n    super(); // 指调用父类的构造函数\n    //实例对象属性\n    this.name = name;\n  }\n  //静态方法\n  static showType() {\n    // 静态方法调用的对象是构造函数 所以静态方法中仅可以使用静态属性\n    return this.type;\n  }\n  // 原型添加函数(所有实例对象可以访问)\n  showName() {\n    return this.name;\n  }\n  }\n  console.dir(Admin);\n  console.dir(new Admin(\"猪琦琦\"));\n</script>\n\n```\n\n### 2.静态访问\n\n#### <u>静态属性</u>\n\n静态属性即为类设置属性，无需实例化即可调用，针对的是构造器设置。\n\n```javascript\n// es5构造函数构造对象\nfunction User(name) {}\n//静态属性\nUser.type = \"用户\";\n\n// class中使用static关键词\nclass Admin extends User {\n  //静态属性\n  static type = \"管理员\";\n}\n```\n\n#### <u>静态方法</u>\n\n```javascript\n// es5形式\nfunction User(name) {}\nUser.showTypea = function() {\n  // 静态方法调用的对象是构造函数 所以静态方法中仅可以使用静态属性\n  return this.type;\n};\n\n// class静态方法\nstatic showType() {\n  // 静态方法调用的对象是构造函数 所以静态方法中仅可以使用静态属性\n  return this.type;\n}\n```\n\n### 3.访问器\n\n访问器可以对对象的属性进行访问控制，访问器可以管控属性，有效的防止属性随意修改，加上get/set修饰，操作是不需要添加函数括号。\n\n```javascript\nclass User {\n  constructor(name) {\n    this.data = { name };\n  }\n  get name() {\n    return this.data.name;\n  }\n  set name(value) {\n    if (value.trim() == \"\") throw new Error(\"invalid params\");\n    this.data.name = value;\n  }\n}\nlet hs = new User(\"花森\");\nhs.name = \"huasen\";\nconsole.log(hs.name);\n```\n\n#### <u>public</u>\n\n`public` 指不受保护的属性，在类的内部与外部都可以访问到。\n\n```javascript\nclass User {\n  url = \"huasenjio\";\n  constructor(name) {\n    this.name = name;\n  }\n}\nlet hs = new User(\"花森\");\nconsole.log(hs.name, hs.url);\n```\n\n#### <u>protected</u>\n\nprotected是受保护的属性修释，不允许外部直接操作，但可以继承后在类内部访问。\n\n```javascript\n// 属性定义为以 _ 开始，来告诉使用者这是一个私有属性，请不要在外部使用，自启提示作用。\nclass Article {\n  _host = \"http://huasenjio.top/\";\n  set host(url) {\n    if (!/^https:\\/\\//i.test(url)) {\n      throw new Error(\"网址错误\");\n    }\n    this._host = url;\n  }\n  lists() {\n    return `${this._host}/article`;\n  }\n}\n```\n\n#### <u>private</u>\n\n`private` 指私有属性，只在当前类可以访问到，并且不允许继承使用，为属性或者方法名前家#则是声明私有属性，属性只能在声明的类中使用。\n\n```javascript\nclass User {\n  #host = \"http://huasenjio.top/\";\n  constructor(name) {\n      this.name = name;\n      this.#check(name);\n    }\n  #check = () => {\n  if (this.name.length <= 5) {\n    throw new Error(\"用户名长度不能小于五位\");\n  }\n  return true;\n  };\n  }\n  class Pig extends User {\n    constructor(name) {\n      super(name);\n      this.name = name;\n    }\n  }\n  let pig = new Pig(\"猪琦猪猪猪户\");\n  // console.log(pig.#host); // '#host' must be declared in an enclosing class\n  // console.log(new User().#host); // '#host' must be declared in an enclosing class\n```\n\n### 4.super\n\n所有继承中 `this` 始终为调用对象，`super` 是用来查找当前对象的原型。在constructor中super指调用父类引用，必须先调用super（）后再进行this赋值。\n\n```javascript\n<script>\n  class User {\n      constructor(name) {\n        this.name = name;\n      }\n    }\n  class Pig extends User {\n    constructor(name, type) {\n      // super会调用父类的constructor构造器，因为父类的name属性是会被Pig继承，所以实例子类时需要将父类需要的参数通过super传递。\n      super(name);\n      this.type = type;\n    }\n  }\n  let pig = new Pig(\"猪琦\", \"猪\");\n  console.log(pig);\n</script>\n\n\n// 实现原理\nfunction Parent(name) {\n  this.name = name;\n}\nfunction User(...args) {\n  Parent.apply(this, args);\n}\nUser.prototype = Object.create(User.prototype)\nUser.prototype.constructor = User;\nconst hs = new User(\"花森\");\nconsole.log(hs.name);\n```\n\n\n\n\n\n# 任务管理\n\nJavaScript 语言的一大特点就是单线程，同一个时间只能处理一个任务。为了协调事件、用户交互、脚本、UI 渲染和网络处理等行为，防止主线程的不阻塞，JavaScript 处理任务是在等待任务、执行任务 、休眠等待新任务中不断循环中，也称这种机制为事件循环。\n\n```javascript\nconsole.log(\"1.花森是同步代码\");\nsetTimeout(function () {\n  console.log(\"6.定时器是宏任务代码\");\n  Promise.resolve().then(() => {\n    console.log(\"7.下次循环才会执行当前微任务\");\n  });\n}, 0);\n// 激活微任务\nPromise.resolve()\n  .then(function () {\n  console.log(\"3.promise1微任务\");\n})\n  .then(function () {\n  console.log(\"4.promise2微任务\");\n})\n  .then(() => {\n  console.log(\"5.单次循环内微任务执行完成后才可以执行宏任务\");\n});\nconsole.log(\"2.huasenjio时同步代码\");\n```\n\n\n\n\n\n# 模块化开发\n\n项目变大时需要把不同的业务分割成多个文件，即模块的思想，模块是比对象与函数更大的单元，使用模块组织程序便于维护与扩展且模块默认运行在严格模式下。使用模块化开发有以下优点：\n\n1. 模块化是一个独立的文件，可以包含函数或者类库；\n2. 使用模块化可以解决全局变量冲突；\n3. 模块可以隐藏内部实现，只对外保留开发接口；\n4. 模块化可以避免全局变量造成打代码不可控；\n5. 模块可以服用提高编码的效率；\n\n### 1.管理引擎\n\n过去JS不支持模块时我们使用`AMD/CMD（浏览器端使用）、CommonJS（Node.js）、UMD(都支持)`等形式定义模块。AMD代表性的是 `require.js`，CMD 代表是淘宝的 `seaJS` 框架。\n\n### 2.基本使用\n\n```javascript\n// html文件中导入模块需要定义属性 type=\"module\"\n<script type=\"module\">\n  import { hs } from \"./a.js\"; // 浏览器中使用必须添加路径\n</script>\n\n// 新建文件a.js内容如下\nexport let hs = {\n  name: \"花森\"\n};\n```\n\n### 3.作用域\n\n模块都有独立的顶级作用域，不同模块之间不可以访问。\n\n```javascript\n<script type=\"module\">\n  let hs = \"huasenjio\";\n</script>\n\n<script type=\"module\">\n  alert(hs); // Error\n</script>\n```\n\n### 4.预解析\n\n模块在导入时只执行一次解析，之后的导入不会再执行模块代码，而使用第一次解析结果，并共享数据，可以在首次导入时完成一些初始化工作。\n\n### 5.导入导出\n\nES6使用基于文件的模块即一个文件一个模块：\n\n1. 使用export导出方法属性；\n2. 使用import导入模块接口；\n3. 使用 * 导入全部模块接口；\n4. 导出的状态和方法都是地址，模块内修改会影响导入的变量；\n\n#### <u>导出模块</u>\n\n定义文件hd.js导出内容如下\n\n```javascript\nexport const site = \"花森导航\";\nexport const func = function() {\n  return \"is a module function\";\n};\nexport class User {\n  show() {\n    console.log(\"user.show\");\n  }\n}\n\n// 别名导出\nexport { site, func as action, User as user };\n```\n\n#### <u>导入模块</u>\n\n```javascript\n// 具名导入（不忽略大小写）\n<script type=\"module\">\n  import { User, site, func } from \"./hd.js\";\n  console.log(site);\n  console.log(User);\n</script>\n\n// 批量导入\n<script type=\"module\">\n  import * as api from \"./hd.js\";\n  console.log(api.site);\n  console.log(api.User);\n</script>\n\n// 别名导入\n<script type=\"module\">\n  import { User as user, func as action, site as name } from \"./hd.js\";\n  let func = \"houdunren\";\n  console.log(name);\n  console.log(user);\n  console.log(action);\n</script>\n```\n\n### 6.默认导出\n\n当文件中导出的内容模块只有一个，也就是说仅需导入一个内容，这时可以使用默认导入，使用default定义默认导出的接口，导入时不需要使用{}且名字任意。\n\n```javascript\n// hd.js文件中暴露导出\ndefault class {\n  static show() {\n    console.log(\"User.method\");\n  }\n}\n\n// html中引入\n<script type=\"module\">\n  import User from \"./hd.js\";\n  User.show();\n</script>\n```\n\n### 7.动态导入\n\n```javascript\n<script>\n  if (true) {\n    let hd = import(\"./hd.js\").then(module => {\n      console.log(module.site);\n    });\n  }\n</script>\n```\n\n### 8.指令总结\n\n| 表达式                                           | 说明             |\n| ------------------------------------------------ | :--------------- |\n| export function show(){}                         | 导出函数         |\n| export const name='花森'                         | 导出变量         |\n| export class User{}                              | 导出类           |\n| export default show                              | 默认导出         |\n| const name = '花森' export {name}                | 导出已经存在变量 |\n| export {name as hd_name}                         | 别名导出         |\n| import defaultVar from 'houdunren.js'            | 导入默认导出     |\n| import {name,show} from 'a.j'                    | 导入命名导出     |\n| Import {name as hdName,show} from 'houdunren.js' | 别名导入         |\n| Import * as api from 'houdunren.js'              | 导入全部接口     |\n\n\n\n\n\n# Promise\n\n`JavaScript` 中存在很多异步操作，`Promise` 将异步操作队列化，按照期望的顺序执行，返回符合预期的结果，可以通过链式调用多个 `Promise` 达到我们的目的，使用promise还可以避免回调地域的现象，当一个Promise建立时执行内部的同步代码，resolve或者reject后开启微任务（then内部代码），并载入微任务队列。\n\n### 1.基本理解\n\n我在打游戏的时候（主进程），突然想吃可乐鸡腿，于是你让猪琦（Promise）开了一个做可乐鸡腿的任务（异步任务），因为不影响你打游戏，所以它叫异步任务。如果猪琦同意接受（resolve）则猪琦将去开始去烹饪，做好叫我吃可乐鸡腿（then中result回调函数）；如果猪琦烹饪时可乐鸡腿发生意外（错误）或者拒绝任务（reject）并将我打了一顿，让我跪键盘（then中error回调函数），如果你没有跪键盘或者其他举措补偿（没设置error回调），则统一按分手（catch）处理。不管怎样最后都会和好（finally），开心的过日子。\n\n```javascript\nnew Promise((resolve, reject) => {\n    resolve(\"成功处理\");\n    reject(\"拒绝处理\");\n  \tconsole.log(\"同步代码\"); // 优先执行\n  })\n    .then(\n    (res) => {\n      console.log(\"成功\", res); // resolve则会执行此方法体\n    },\n    (err) => {\n      console.log(\"拒绝\", err); // 语法错误与reject则执行此方法体\n    }\n  )\n    .catch((error) => {\n    console.log(\"发生语法错误\"); // 未设置reject回调函数时交给catch统一处理\n  });\n```\n\n#### <u>状态说明</u>\n\nPromise包含`pending、fulfilled、rejected`三种状态，Promise是队列状态，状态可一直向后传递，每一个Promise都可以改变状态，Promise可以链式传递一个传一个。\n\n![dVQlfMuh4gCNaeT](https://s2.loli.net/2022/05/19/dVQlfMuh4gCNaeT.png)\n\n\n\n1. `pending` 初始等待状态，可由`new Promise()`获得该状态；\n2. `resolve` 已经解决， `promise` 状态设置为`fulfilled` ，可由`Promise.resolve()`获得该状态；\n3. `reject` 拒绝处理， `promise` 状态设置为`rejected`，可由`Promise.reject()`获得该状态；\n4. `promise` 是生产者，通过 `resolve` 与 `reject` 函数告知异步任务的状态，一旦状态改变将不可更改；\n\n### 2.异步加载\n\n```javascript\nfunction load(file, resolve, reject) {\n  const script = document.createElement(\"script\");\n  script.src = file;\n  script.onload = resolve;\n  script.onerror = reject;\n  document.body.appendChild(script);\n}\nload(\n  \"./js/hs.js\",\n  script => {\n    console.log(`${script.path[0].src} 加载成功`);\n    hs();\n  },\n  error => {\n    console.log(`${error.srcElement.src} 加载失败`);\n  }\n);\n```\n\n### 3.then\n\npromise 需要提供一个then方法访问promise 结果，`then` 用于定义当 `promise` 状态发生改变时的处理，即`promise`处理异步操作，`then` 用于结果处理输出。\n\n1. then方法必须返回Promise，手动返回或者系统自动返回；\n2. 执行resolve时跳入then方法中的第一个回调参数；\n3. 执行reject时跳入then方法中的第二个回调参数；\n\n```javascript\n<script>\n  new Promise((resolve, reject) => {\n    resolve(\"成功\");\n  })\n    .then((res) => {\n    console.log(\"1\" + res);\n    return new Promise((resolve, reject) => {\n      resolve(\"成功\");\n    });\n  })\n    .then((res) => {\n    console.log(\"2\" + res);\n    // 如果返回的是未处理的Promise则阻塞等待处理\n    return new Promise((resolve, reject) => {\n      reject(\"失败\");\n    });\n  })\n    .then(null, (err) => {\n    console.log(\"3\" + err);\n    return \"then链式调用默认执行resolve回调方法并将return指赋值给res\";\n  })\n    .then((res) => {\n    console.log(\"4\" + res);\n  })\n    .catch((error) => {\n    console.log(error);\n  });\n</script>\n```\n\n### 4.catch\n\ncatch用于失败状态的处理函数，等同于 `then(null,reject){}`，建议使用catch统一处理错误。如果不存在reject回调函数则会跳入catch方法，整一个Promise链上的错误都可以被catch捕获。\n\n```javascript\nnew Promise((resolve, reject) => {\n  resolve(\"成功\");\n  })\n    .then((res) => {\n    console.log(\"1\" + res);\n    abc; // 这个错误一直下沉，直到找到reject回调方法，如果then链上没有同意由catch捕获。\n    return new Promise((resolve, reject) => {\n      resolve(\"成功\");\n    });\n  })\n    .then((res) => {\n    console.log(\"2\" + res);\n    // 如果返回的是未处理的Promise则阻塞等待处理\n    return new Promise((resolve, reject) => {\n      reject(\"失败\");\n    });\n  })\n    .then(null, (err) => {\n    console.log(\"3\" + err);\n    return \"then链式调用默认执行resolve回调方法并将return指赋值给res\";\n  })\n    .then((res) => {\n    console.log(\"4\" + res);\n  })\n    .catch((error) => {\n    console.log(error);\n  });\n```\n\n### 5.事件处理\n\nunhandledrejection事件用于捕获到未处理的Promise错误，下面的 then 产生了错误，但没有`catch` 处理，这时就会触发事件。\n\n```javascript\nwindow.addEventListener(\"unhandledrejection\", function(event) {\n  console.log(event.promise); // 产生错误的promise对象\n  console.log(event.reason); // Promise的reason\n});\n\nnew Promise((resolve, reject) => {\n  resolve(\"success\");\n}).then(msg => {\n  throw new Error(\"fail\");\n});\n```\n\n### 6.finally\n\n无论状态是`resolve` 或 `reject` 都会执行此动作\n\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  reject(\"hs\");\n})\n.then(msg => {\n  console.log(\"resolve\");\n})\n.catch(msg => {\n  console.log(\"reject\");\n})\n.finally(() => {\n  console.log(\"resolve/reject状态都会执行\");\n});\n```\n\n### 7.拓展接口\n\n#### <u>resolve</u>\n\n使用 `Promise.resolve()` 方法可以快速的返回一个状态为fulfilled的promise对象\n\n```javascript\nPromise.resolve(\"花森\").then(value => {\n  console.log(value); // 花森\n});\n```\n\n#### <u>reject</u>\n\n使用 `Promise.reject()` 方法可以快速的返回一个状态为rejected的promise对象\n\n```javascript\nPromise.reject(\"花森\").then(null,err => {\n  console.log(err); // 花森\n});\n```\n\n#### <u>all</u>\n\n使用`Promise.all` 方法可以同时执行多个并行异步操作，等待多个promise完成任务后返回一个有序的数组，需要注意一下几点：\n\n1. 任何一个Promise执行失败都会调用catch方法；\n2. 一次发送多个异步操作；\n3. 参数必须是可迭代对象例如Array和Set；\n\n```javascript\nconst hs = new Promise((resolve, reject) => {\n  setTimeout(() => {\n      resolve(\"第一个Promise\");\n    }, 1000);\n  });\n  const zhuqi = new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(\"第二个Promise\");\n    }, 1000);\n  });\n  const h = Promise.all([hs, zhuqi])\n  .then((results) => {\n    console.log(results);\n  })\n  .catch((msg) => {\n    console.log(msg);\n  });\n  setTimeout(() => {\n    console.log(h);\n  }, 1000);\n```\n\n#### <u>allSettled</u>\n\n`allSettled` 用于处理多个`promise` ，只关注执行完成，不关注是否全部执行成功，`allSettled` 状态只会是`fulfilled`。\n\n```javascript\nconst p1 = new Promise((resolve, reject) => {\n  resolve(\"resolved\");\n});\nconst p2 = new Promise((resolve, reject) => {\n  reject(\"rejected\");\n});\nPromise.allSettled([p1, p2])\n.then(msg => {\n  console.log(msg);\n})\n```\n\n#### <u>race</u>\n\n使用`Promise.race()` 处理容错异步，队列中Promise优先执行则优先返回，具有一下的几点特性：\n\n1. 最快返回的promise为准；\n2. 如果传入参数不是Promise则内部自动转为Promise；\n3. 无论内部的Promise返回的转态是reject还是resolve，race都会返回一个`fulfilled`状态promise，如果传入的Promise都存在语法错误则会返回一个Pending状态的Promise；\n\n```javascript\nconst hs = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject(\"第一个Promise\");\n  }, 1000);\n});\nconst zhuqi = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject(\"第二个Promise\");\n  }, 3000);\n});\nconst h = Promise.race([hs, zhuqi])\n.then((results) => {\n  console.log(\"成功\" + results);\n})\n.catch((msg) => {\n  console.log(\"错误\" + msg);\n});\nsetTimeout(() => {\n  console.log(h); // Promise {<fulfilled>: undefined}\n}, 4000);\n```\n\n### 8.async/await\n\n使用 `async/await` 是promise 的语法糖，可以让编写 promise 更清晰易懂。\n\n#### <u>async</u>\n\n函数前加上async关键词，函数将返回promise就可以像使用标准Promise一样使用了。\n\n```javascript\nasync function hs() {\n  return \"huasenjio\";\n}\nconsole.log(hs());\nhs().then((value) => {\n  console.log(value);\n});\n```\n\n#### <u>await</u>\n\n使用`await`关键词后面的Promise执行完成则继续向下执行，否则阻塞等待，内部await一旦有一个出现reject或者语法错误，则直接跳入err的回调函数中，具有一下特性：\n\n1. await后面跟Promise，若不是则直接返回后面值；\n2. await必须放在async定义的函数中使用；\n3. await用于代替then的链式调用；\n\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(\"promise处理\");\n  }, 1000);\n});\nconst huasen = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject(\"p拒绝\"); // 一旦出现拒绝又不进行处理，直接跳入err回调函数中，下面的代码将不再执行。\n  }, 1000);\n});\nasync function hs() {\n  let result = await promise;\n  console.log(\"需要等待await完成\");\n  let res = await huasen;\n\n  return \"执行完成\"; // 如果不存在语法错误且不拒绝，则返回值跳入resolve回调函数中的res参数中。\n}\nhs().then(\n  (res) => {\n    console.log(\"成功\", res);\n  },\n  (err) => {\n    console.log(\"失败\", err);\n  }\n);\n```\n\n\n\n\n\n# DOM\n\n浏览器解析HTML文件时会生成一个DOM对象，JS可以调用控制页面元素，但需要注意的是操控是浏览器以及渲染了页面内容，否则无法读取到节点对象。\n\n### 1.节点对象\n\nhtml中的每一个标签对应着js中的一个DOM节点对象，包含有属性方法，可以调用，以下是对象的基本知识：\n\n1. 包括有12种类型节点对象；\n2. 常用节点对象为`document、标签元素节点、文本节点、注释节点`；\n3. 节点均继承node对象，所以拥有相同的属性和方法；\n4. document节点是DOM的根节点；\n\n| 类型         | 值                      |\n| ------------ | ----------------------- |\n| 元素节点     | 1（body对象）           |\n| 属性节点     | 2（标签属性）           |\n| 文本节点     | 3（标签内文字）         |\n| 注释节点     | 8（标签内注释）         |\n| 文档节点     | 9（document对象）       |\n| 文档类型节点 | 10（`<!DOCTYPE html>`） |\n\n```javascript\n<body id=\"hs\">\n  <!-- 花森 -->\n  huasenjio\n</body>\n<script>\n  console.log(document.nodeType) //9 document对象\n  console.log(document.childNodes.item(0).nodeType) //10\n  console.log(document.body.nodeType) //1\n  console.log(document.body.attributes[0].nodeType) //2\n  console.log(document.body.childNodes[1].nodeType) //8\n</script>\n```\n\n### 2.DOM原型链\n\n浏览器渲染过程中会将文档内容生成为不同的对象，不同的节点类型有专门的构造参数创建对象，使用`console.dir`可以查看详细属性方法，节点也是对象所以觉有JS对象的特征，有以下节点类型：\n\n| 原型               | 说明                                                    |\n| ------------------ | ------------------------------------------------------- |\n| Object             | 根对象                                                  |\n| EventTarget        | 提供事件支持                                            |\n| Node               | 提供parentNode等节点操作方法                            |\n| Element            | 提供getElementsByTagName、querySelector样式选择器等方法 |\n| HTMLElement        | 所有元素的基础类 提供className、nodeName等方法          |\n| HTMLHeadingElement | Head标题元素类                                          |\n\n````javascript\n<div id=\"hs\">花森酱</div>\n<input type=\"text\" name=\"title\" id=\"title\" />\n  <script>\n  let hs = document.getElementById(\"id\");\nfunction prototype(el) {\n  let proto = Object.getPrototypeOf(el); // 获取对象原型\n  console.log(proto);\n  Object.getPrototypeOf(proto) ? prototype(proto) : \"\"; // 递归获取\n}\nprototype(hs);\n</script>\n````\n\n#### <u>对象合并</u>\n\n```javascript\n<div id=\"hs\">huasenjio</div>\n<script>\n  let hs = document.getElementById('hs')\n  Object.assign(hs, {\n    color: 'red',\n    change() {\n      this.innerHTML = '花森酱'\n      this.style.color = this.color\n    },\n    onclick() {\n      this.change()\n    },\n  })\n</script>\n```\n\n#### <u>样式合并</u>\n\n```javascript\n<div id=\"hs\">huasenjio</div>\n<script>\n  let hs = document.getElementById('hs')\n  Object.assign(hs.style, {\n    color: 'red',\n  })\n</script>\n```\n\n### 3.页面文档\n\ndocument是window对象的属性，是由HTMLDocument类实现的实例，继承node类则可以用node的相关方法，document文档包含着页面唯一的元素标签。\n\n#### <u>html</u>\n\n系统提供了简单的方式来获取html元素\n\n```javascript\nconsole.log(document.documentElement)\n```\n\n#### <u>文档信息</u>\n\n使用title获取和设置文档标题\n\n```javascript\n//获取文档标题\nconsole.log(document.title)\n\n//设置文档标签\ndocument.title = '花森酱测试文件'\n\n//获取当前URL\nconsole.log(document.URL)\n\n//获取域名\ndocument.domain\n\n//获取来源地址\nconsole.log(document.referrer)\n```\n\n#### <u>body</u>\n\n可通过`document.body`获取到页面\n\n### 4.节点属性\n\n#### <u>nodeType</u>\n\n不同类型的节点拥有不同的属性，nodeType指以数值返回节点类型，递归获取元素某节点下的全部标签元素，以下是类型展示：\n\n| nodeType | 说明         |\n| -------- | ------------ |\n| 1        | 元素节点     |\n| 2        | 属性节点     |\n| 3        | 文本节点     |\n| 8        | 注释节点     |\n| 9        | document对象 |\n\n```javascript\n<div id=\"hs\">\n  <ul>\n  <li>\n  <h2><strong>花森</strong></h2>\n    </li>\n</ul>\n</div>\n<script>\n    function all(el) {\n    let items = [];\n    [...el.childNodes].map((node) => {\n      if (node.nodeType == 1) {\n        items.push(node, ...all(node));\n      }\n    });\n    return items;\n  }\nconsole.log(all(document.body));\n</script>\n```\n\n#### <u>nodeName</u>\n\nnodeName指定节点的名称，获取值为大写形式，注意空行也是一个文本节点。\n\n| nodeType | nodeName      |\n| -------- | ------------- |\n| 1        | 元素名称如DIV |\n| 2        | 属性名称      |\n| 3        | #text         |\n| 8        | #comment      |\n\n### 5.节点集合\n\nNodelist与HTMLCollection都是包含多个节点标签的集合\n\n1. getElementsBy...等方法返回的是HTMLCollection；\n2. querySelectorAll样式选择器返回的是 NodeList；\n3. NodeList和NodeList集合是动态的；\n\n#### <u>length</u>\n\nNodelist与HTMLCollection包含length属性则记录节点元素的数量\n\n#### <u>转换数组</u>\n\n有时使用数组方法来操作节点集合，这就需要将节点集合转化为数组类型，有以下几种方式可以实现。\n\n```javascript\n// Array.from()\nconsole.log(Array.from(elements))\n\n// 点语法\n[...elements]\n```\n\n### 6.常用元素\n\n系统针对特定标签提供了快速选择的方式\n\n| 方法                     | 说明                   |\n| ------------------------ | ---------------------- |\n| document.documentElement | 文档节点即html标签节点 |\n| document.body            | body标签节点           |\n| document.head            | head标签节点           |\n| document.links           | 超链接集合             |\n| document.anchors         | 所有锚点集合           |\n| document.forms           | form表单集合           |\n| document.images          | 图片集合               |\n\n### 7.节点关系\n\n节点是根据HTML内容产生的，所以也存在父子、兄弟、祖先、后代等节点关系，下例中的代码就会产生这种多重关系，目前文本节点也会匹配上关系。\n\n1. h1与ul是兄弟关系；\n2. span与li是父子关系；\n3. ul与span是后代关系；\n4. span与ul是祖先关系；\n\n```html\n<h1>花森</h1>\n<ul>\n  <li>\n    <span>huasen</span>\n    <strong>猪琦</strong>\n  </li>\n</ul>\n```\n\n| 节点属性        | 说明             |\n| --------------- | ---------------- |\n| childNodes      | 获取所有子节点   |\n| parentNode      | 获取父节点       |\n| firstChild      | 子节点中第一个   |\n| lastChild       | 子节点中最后一个 |\n| nextSibling     | 下一个兄弟节点   |\n| previousSibling | 上一个兄弟节点   |\n\n### 8.元素关系\n\n使用childNodes等获取的节点包括文本与注释\n\n| 节点属性               | 说明             |\n| ---------------------- | :--------------- |\n| parentElement          | 获取父元素       |\n| children               | 获取所有子元素   |\n| childElementCount      | 子标签元素的数量 |\n| firstElementChild      | 第一个子标签     |\n| lastElementChild       | 最后一个子标签   |\n| previousElementSibling | 上一个兄弟标签   |\n| nextElementSibling     | 下一个兄弟标签   |\n\n### 9.选择器\n\n系统提供了丰富的选择节点（NODE）的操作方法\n\n#### <u>getElementById</u>\n\n使用ID选择是非常方便的选择具有ID值的节点元素，此方法仅存在与document对象上。\n\n```javascript\n<div id=\"hs\">huasen</div>\n<div id=\"app\"></div>\n<script>\n  function getByElementIds(ids) {\n  return ids.map((id) => document.getElementById(id));\n}\nlet nodes = getByElementIds([\"hs\", \"app\"]);\nconsole.dir(nodes);\n</script>\n```\n\n#### <u>getElementByClassName</u>\n\ngetElementsByClassName用于按class 样式属性值获取元素集合\n\n```javascript\nconst nodes = document.getElementsByClassName('hs')\n```\n\n#### <u>getElementByName</u>\n\n使用getElementByName获取设置了name属性的元素，返回NodeList节点列表对象，顺序即元素在文档中的顺序。\n\n```javascript\n<div name=\"hs\">花森</div>\n<script>\n  const div = document.getElementsByName(\"hs\");\nconsole.dir(div);\n</script>\n```\n\n#### <u>getElementByTagName</u>\n\n使用getElementsByTagName用于按标签名获取元素\n\n```javascript\nconst divs = document.getElementsByTagName('div')\n```\n\n#### <u>通配符</u>\n\n可以使用通配符`*`获取所有元素\n\n```javascript\nconst nodes = document.getElementsByTagName('*')\n```\n\n#### <u>querySelectorAll</u>\n\n在DOM操作中也可以使用这种方式查找元素，使用querySelectorAll根据CSS选择器获取Nodelist节点列表，获取的NodeList节点列表是静态的就是添加或者删除元素后list不会发生变化。\n\n```javascript\n<div id=\"app\">\n  <div>花森/div>\n  <div>猪琦</div>\n</div>\n<script>\n  const app = document.body.querySelectorAll(\"#app\")[0];\nconst nodes = app.querySelectorAll(\"div\");\nconsole.log(nodes); //2\n</script>\n```\n\n#### <u>querySelector</u>\n\nquerySelector使用CSS选择器获取一个元素\n\n```javascript\nconst nodes = app.querySelectorAll(\"div\");\n```\n\n#### <u>matches</u>\n\n用于检测元素是否是指定的样式选择器匹配\n\n```javascript\n<div id=\"app\" class=\"app\">\n  <div>花森/div>\n  <div>猪琦</div>\n</div>\n<script>\n  const app = document.body.querySelectorAll(\"#app\")[0];\nconsole.log(app.matches(\".app\")) // true\n</script>\n```\n\n#### <u>closest</u>\n\n根据样式查找某元素最近的祖先元素\n\n```javascript\n// 这个例子是查找li元素最近的祖先并且符合`.comment`样式\n<div class=\"comment\">\n  <ul class=\"comment\">\n    <li>huasenjio</li>\n</ul>\n</div>\n\n<script>\n    const li = document.getElementsByTagName(\"li\")[0];\nconst node = li.closest(`.comment`);\nconsole.log(node);\n</script>\n```\n\n### 10.动态与静态\n\n通过 getElementsByTagname 等getElementsByXXX函数获取的Nodelist与HTMLCollection集合是动态，即有元素添加或移动操作集合将实时反映最新状态。\n\n1. 使用getElement...返回的都是动态的集合；\n2. 使用querySelectorAll返回的是静态集合；\n\n```javascript\n<h1>花森导航</h1>\n<h1>huasenjio</h1>\n<button id=\"add\">添加元素</button>\n\n<script>\n  let elements = document.getElementsByTagName(\"h1\");\n\t//let elements = document.querySelectorAll(\"h1\");\nconsole.log(elements);\nlet button = document.querySelector(\"#add\");\nbutton.addEventListener(\"click\", () => {\n  document\n    .querySelector(\"body\")\n    .insertAdjacentHTML(\"beforeend\", \"<h1>hs</h1>\");\n  console.log(elements);\n});\n</script>\n```\n\n### 11.元素特征\n\n标准的属性(src|className|herf）可以使用DOM属性的方式进行操作，但是对于非标准的属性则不可以，可以理解为元素的属性分两个地方保存，DOM属性记录标准属性，特征中记录标准和定制属性。简而言之就是对奇怪的属性进行操作，有以下几种方法：\n\n| 方法            | 说明     |\n| --------------- | -------- |\n| getAttribute    | 获取属性 |\n| setAttribute    | 设置属性 |\n| removeAttribute | 删除属性 |\n| hasAttribute    | 属性检测 |\n\n#### <u>attributes</u>\n\n元素提供了attributes 属性可以只读的获取元素的属性\n\n```javascript\n<div class=\"hs\" data-content=\"花森\">hs.com</div>\n<script>\n  let hs = document.querySelector(\".hs\");\nconsole.dir(hs.attributes[\"class\"].nodeValue); //hs\nconsole.dir(hs.attributes[\"data-content\"].nodeValue); //后盾人\n</script>\n```\n\n#### <u>hasAttribute</u>\n\n用于检测对象是否存在某个属性\n\n```javascript\nconsole.log(hdcms.hasAttribute('class')) //false\n```\n\n#### <u>自定义属性</u>\n\n虽然可以随意定义特征并使用getAttribute等方法管理，建议使用以data-为前缀的自定义特征处理，针对这种定义方式JS也提供了接口方便操作。\n\n1. 元素中以`data-`作为前缀的属性会添加按到属性map集合中；\n2. 使用元素的dataset可以获取属性集合中的属性；\n3. 改变dataset的值也会影响元素；\n\n```javascript\n<div class=\"hs\" data-title-color=\"red\">花森酱</div>\n<script>\n  let hs = document.querySelector(\".hs\");\n\tconsole.log(hs.dataset);\n\ths.innerHTML = `\n\t<span style=\"color:${hs.dataset.titleColor}\">${hs.innerHTML}</span>`;\n</script>\n```\n\n### 12.创建节点\n\n创建节点的就是构建出DOM对象\n\n#### <u>createTextNode</u>\n\n创建文本对象并添加到元素中\n\n```javascript\n<div id=\"app\"></div>\n<script>\n  let app = document.querySelector('#app')\n  let text = document.createTextNode('花森')\n  app.append(text)\n</script>\n```\n\n#### <u>createElement</u>\n\n使用createElement方法可以标签节点对象\n\n```javascript\n<div id=\"app\"></div>\n<script>\n  let app = document.querySelector('#app')\n  let span = document.createElement('span')\n  span.innerHTML = '花森酱'\n  app.append(span)\n</script>\n```\n\n#### <u>createDocumentFragment</u>\n\n使用createDocumentFragment创建虚拟节点容器具有一下特点：\n\n1. 创建的节点的parentNode为Null；\n2. 使用createDocumentFragment创建的节点来暂存文档节点；\n3. createDocumentFragment创建的节点添加到其他节点上时；\n4. 不直接操作DOM所以性能更好；\n5. 排序/移动等大量DOM操作时建议使用createDocumentFragment；\n\n#### <u>cloneNode&importNode</u>\n\n使用cloneNode和document.importNode用于复制节点对象操作\n\n1. cloneNode是节点方法；\n2. cloneNode参数为true时递归赋值子节点即深拷贝；\n3. importNode是document对象方法；\n\n```javascript\n<div id=\"app\">huasen</div>\n<script>\n  let app = document.querySelector('#app')\n  let newApp = app.cloneNode(true)\n  document.body.appendChild(newApp)\n</script>\n```\n\n### 13.节点内容\n\n#### <u>innerHTML</u>\n\ninneHTML用于向标签中添加html内容，同时出发浏览器的解析器重绘DOM树。\n\n```javascript\n<div id=\"app\"></div>\n<script>\n  let app = document.querySelector(\"#app\");\n\tconsole.log(app.innerHTML);\n\n\tapp.innerHTML = \"<h1>花森</h1>\";\n</script>\n```\n\n#### <u>outerHTML</u>\n\nouterHTML与innerHTML的区别是包含父标签，不会将原来的内容删除掉依然在DOM树节点上。\n\n```javascript\n<div id=\"app\">\n  <div class=\"hs\" data=\"hs\">花森</div>\n  <div class=\"zhuqi\">猪琦</div>\n</div>\n<script>\n  let app = document.querySelector('#app')\n  console.log(app.outerHTML)\n\n  app.outerHTML = '<h1>酱</h1>'\n</script>\n```\n\n#### <u>textContent与innerText</u>\n\ntextContent与innerText是访问或添加文本内容到元素中\n\n```javascript\n<div id=\"app\">\n  <div class=\"hs\" data=\"hs\">花森</div>\n  <div class=\"zhuqi\">猪琦</div>\n</div>\n<script>\n  let app = document.querySelector('#app')\n  console.log(app.outerHTML)\n\n  app.textContent = '<h1>酱</h1>'\n</script>\n```\n\n#### <u>insertAdjacentText</u>\n\n将文本插入到元素指定位置，不会对文本中的标签进行解析，即不会将`<h1>皮卡丘</h1>`以HTML标签形式去渲染。\n\n| 选项        | 说明         |\n| ----------- | ------------ |\n| beforebegin | 元素本身前面 |\n| afterend    | 元素本身后面 |\n| afterbegin  | 元素内部前面 |\n| beforeend   | 元素内部后面 |\n\n```html\n<div id=\"app\">\n  <div class=\"hs\">花森</div>\n  <div class=\"zq\">猪琦</div>\n</div>\n<script>\n  let app = document.querySelector(\".hs\");\n  app.insertAdjacentText(\"afterend\", \"<h1>皮卡丘</h1>\");\n</script>\n```\n\n### 14.节点管理\n\n节点元素的管理，包括添加、删除、替换等操作，具体有以下参数位置：\n\n#### <u>推荐方法</u>\n\n| 方法        | 说明                       |\n| ----------- | -------------------------- |\n| append      | 节点尾部添加新节点或字符串 |\n| prepend     | 节点开始添加新节点或字符串 |\n| before      | 节点前面添加新节点或字符串 |\n| after       | 节点后面添加新节点或字符串 |\n| replaceWith | 将节点替换为新节点或字符串 |\n\n```javascript\n<div id=\"app\">花森酱</div>\n<script>\n  let app = document.querySelector(\"#app\");\n\tapp.append(\"huasenjio.top\");\n</script>\n```\n\n#### <u>inserAdjacentHTML</u>\n\nhtml文本插入到元素指定位置，浏览器会对文本进行标签解析，具有包括以下参数位置：\n\n| 选项        | 说明         |\n| ----------- | ------------ |\n| beforebegin | 元素本身前面 |\n| afterend    | 元素本身后面 |\n| afterbegin  | 元素内部前面 |\n| beforeend   | 元素内部后面 |\n\n```html\n<div id=\"app\">花森酱</div>\n<script>\n  let app = document.querySelector(\"#app\");\n\tapp.insertAdjacentHTML(\"afterbegin\",'<h1>后盾人</h1>');\n</script>\n```\n\n#### <u>inserAdjacentElement</u>\n\nnsertAdjacentElement() 方法将指定元素插入到元素的指定位置\n\n1. 第一个参数是位置；\n2. 第二个参数为新元素节点；\n\n```html\n<div id=\"app\">花森酱</div>\n<script>\n  let app = document.querySelector(\"#app\");\n  let span = document.createElement('span')\n\tapp.insertAdjacentHTML(\"afterbegin\",span);\n</script>\n```\n\n#### <u>古老管理手法</u>\n\n下面列表过去使用的操作节点的方法\n\n| 方法         | 说明                           |\n| ------------ | ------------------------------ |\n| appendChild  | 添加节点                       |\n| insertBefore | 用于插入元素到另一个元素的前面 |\n| removeChild  | 删除节点                       |\n| replaceChild | 进行节点的替换操作             |\n\n### 15.表单控制\n\n#### <u>表单查找</u>\n\nJS为表单的操作提供了单独的集合控制\n\n- 使用document.forms获取表单集合；\n- 使用form的name属性获取指定form元素；\n- 根据表单项的name属性使用form.elements.title获取表单项；\n- 直接写成form.name形式；\n- 针对radio/checkbox获取的表单项是一个集合；\n\n```javascript\n<form action=\"\" name=\"hs\">\n  <input type=\"text\" name=\"title\" />\n</form>\n<script>\n    const form = document.forms.hs;\nconsole.log(form.title.form === form); //true\n</script>\n```\n\n### 16.样式管理\n\n通过DOM修改样式可以通过更改元素的class属性或通过style对象设置行样式来完成\n\n#### <u>className</u>\n\n使用JS的className可以批量设置样式，style中设置对应的类名，达到修改样式的目的。\n\n```javascript\nlet app = document.getElementById('app')\napp.className = 'hs'\n```\n\n#### <u>classList</u>\n\n通过使用 classList属性，添加移除操作操作，实现样式和dom的绑定。\n\n| 方法                    | 说明     |\n| ----------------------- | -------- |\n| node.classList.add      | 添加类名 |\n| node.classList.remove   | 删除类名 |\n| node.classList.toggle   | 切换类名 |\n| node.classList.contains | 类名检测 |\n\n```javascript\nlet app = document.getElementById('app')\napp.classList.add('hs')\nconsole.log(app.classList.contains('hs')) //false\n```\n\n#### <u>单个样式属性设置</u>\n\n使用节点的style对象来设置行样式，单词采用驼峰命名法。\n\n```javascript\nlet app = document.getElementById('app')\napp.style.backgroundColor = 'red'\napp.style.color = 'yellow'\n```\n\n#### <u>批量设置样式</u>\n\n```javascript\n// 方式一\nlet app = document.getElementById('app')\napp.style.cssText = `background-color:red;color:yellow`\n\n// 方式二\napp.setAttribute('style', `background-color:red;color:yellow;`)\n```\n\n### 17.样式获取\n\n#### <u>style</u>\n\n可以使用DOM对象的style属性读取行样式，需要注意的是style对象仅可以获取内联样式属性。\n\n```html\n\t<head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>测试</title>\n    <style>\n      div {\n        color: yellow;\n      }\n    </style>\n  </head>\n  <body>\n    <div id=\"app\" style=\"background-color: red; margin: 20px\">后盾人</div>\n    <script>\n      let app = document.getElementById(\"app\");\n      console.log(app.style.backgroundColor);\n      console.log(app.style.margin);\n      console.log(app.style.marginTop);\n      console.log(app.style.color);\n    </script>\n  </body>\n```\n\n#### <u>getComputedStyle</u>\n\n使用window.getComputedStyle可获取所有应用在元素上的样式属性，第一个参数为元素，第二个参数为伪类，此方式获得的是经过计算后的样式属性，可能与真实的设置值有所不同。\n\n```js\nlet fontSize = window.getComputedStyle(app).fontSize\n```\n\n\n\n\n\n# 空间坐标\n\n### 1.基础理解\n\n首先参考画布分为视口（窗口）与文档的含义\n\n1. 文档尺寸一般大于视口尺寸；\n2. F12打开控制台会造成尺寸相应变小；\n3. 视口的尺寸不包括浏览器的菜单和状态栏等；\n4. 视口坐标的操作需要考虑滚动条的位置；\n\n\n\n![IURmlLX5W7rbpu8](https://s2.loli.net/2022/05/19/IURmlLX5W7rbpu8.png)\n\n### 2.视口文档\n\n获取浏览器视口宽度的集中方法\n\n| 方法                                  | 说明     | 注意                 |\n| ------------------------------------- | -------- | -------------------- |\n| window.innerWidth                     | 视口宽度 | 包括滚动条（不常用） |\n| window.innerHeight                    | 视口高度 | 包括滚动条（不常用） |\n| document.documentElement.clientWidth  | 视口宽度 |                      |\n| document.documentElement.clientHeight | 视口高度 |                      |\n\n### 3.定位方向\n\n|                                 |                                         |                                |\n| ------------------------------- | --------------------------------------- | ------------------------------ |\n| 方法                            | 说明                                    | 备注                           |\n| element.getBoundingClientRect() | 返回元素相对于视口的坐标信息            | 窗口坐标                       |\n| element.getClientRects          | 行级元素每行尺寸位置组成的数组          |                                |\n| element.offsetParent            | 拥有定位属性的父级                      | 对于隐藏元素/body/html值为null |\n| element.offsetWidth             | 元素宽度尺寸（内边距+边框+宽）          |                                |\n| element.offsetHeight            | 元素高度尺寸（内边距+边框+高）          |                                |\n| element.offsetLeft              | 相对于祖先元素的X轴坐标                 |                                |\n| element.offsetTop               | 相对于祖先元素的Y轴坐标                 |                                |\n| element.clientWidth             | 内容宽度（width+内边距）（行级元素为0） |                                |\n| element.clientHeight            | 内容宽度（width+内边距）（行级元素为0） |                                |\n| element.clientLeft              | 内容距离外部的距离                      |                                |\n| element.clientTop               | 内容距离顶部的距离                      |                                |\n| element.scrollWidth             | 元素宽度 内容+内边距+内容溢出的尺寸     |                                |\n| element.scrollHeight            | 元素高度 内容+内边距+内容溢出的尺寸     |                                |\n| element.scrollLeft              | 水平滚动条左侧已经滚动的宽度            |                                |\n| element.scrollTop               | 垂直滚动条顶部已经滚动的高度            |                                |\n\n### 4.坐标判断\n\n获取相对于视口的xy坐标上的元素，如果坐标定在视口外则返回值为null。\n\n| 方法                      | 说明                         |\n| ------------------------- | ---------------------------- |\n| element.elementsFromPoint | 返回指定坐标点所在的元素集合 |\n| element.elementFromPoint  | 返回指定坐标点最顶级的元素   |\n\n### 5.滚动控制\n\n| 方法                                   | 说明                           | 参数说明                                                     |\n| -------------------------------------- | ------------------------------ | ------------------------------------------------------------ |\n| window.pageXOffset                     | 文档相对窗口水平滚动的像素距离 |                                                              |\n| window.pageYOffset                     | 文档相对窗口垂直滚动的像素距离 |                                                              |\n| element.scrollLeft()                   | 元素X轴滚动位置                |                                                              |\n| element.scrollTop()                    | 元素Y轴滚动位置                |                                                              |\n| element.scrollBy()                     | 按偏移量进行滚动内容           | 参数为对象{top:垂直偏移量,left:水平偏移量,behavior:'滚动方式'} |\n| element.scroll() 或 element.scrollTo() | 滚动到指定的具体位置           | 参数为对象{top:X轴文档位置,left:Y轴文档位置,behavior:'滚动方式'} |\n| element.scrollLeft                     | 获取和设置元素X轴滚动位置      | 设置X轴文档位置                                              |\n| element.scrollTop                      | 获取和设置元素Y轴滚动位置      | 设置Y轴文档位置                                              |\n| element.scrollIntoView(bool)           | 定位到顶部或底部               | 参数为true元素定位到顶部                                     |\n\n```javascript\ndocument.documentElement.scroll({ top: 30, behavior: 'smooth' })\n```\n\n\n\n\n\n# 网络请求\n\n浏览器天生具发送HTTP请求的能力\n\n### 1.XMLHttpRequest\n\n使用XMLHttpRequest发送请求数据\n\n```javascript\n// 通过XMLHttpRequst封装Ajax网络请求\n// 实例：HuaSenAjax.get(url,options,data)，HuaSenAjax.post(url,options,data)，new HuaSenAjax(\"GET\",url,options,data)，默认请求GET且异步请求，函数返回一个Promise对象。\nclass HuaAjaxTools {\n  // 定义返回类型为JSON类型\n  options = {\n    responseType: \"json\",\n  };\n  // 构造函数，默认get请求，默认不传参数，参数列表options用于覆盖。\n  constructor(method = \"GET\", url, options, data = null, async = true) {\n    this.method = method;\n    this.url = url;\n    this.data = this.formatData(data);\n    this.async = async;\n    Object.assign(this.options, options); // 合并覆盖参数\n  }\n  // 格式化处理参数，处理将POST请求数据序列化。\n  formatData(data) {\n    if (typeof data != \"object\" || data == null) data = {};\n    let form = new FormData(); // FormData类型其实是在XMLHttpRequest2级定义，它是为序列化表以及创建与表单格式相同的数据（当然是用于XHR传输）提供便利。\n    for (const [name, value] of Object.entries(data)) {\n      form.append(name, value); //添加至序列化列表中\n    }\n    return form;\n  }\n  // 处理连接参数的静态方法\n  static handleUrl(url = null, data = null) {\n    if (typeof url != \"string\" || url == null) url = \"\";\n    if (typeof data != \"object\" || data == null) data = {};\n    if (Object.keys(data).length !== 0) {\n      url = url.replace(/\\/$/, \"\") + \"?\";\n      let params = \"\";\n      for (const [name, value] of Object.entries(data)) {\n        params += \"&\" + name + \"=\" + encodeURIComponent(value);\n      }\n      params = params.replace(/^&/, \"\"); // 利用正则去除参数中的第一个&符号\n      url = url + params;\n    }\n    return url;\n  }\n  // 声明get静态方法\n  static get(url, options, data) {\n    try {\n      url = this.handleUrl(url, data);\n      return new this(\"GET\", url, options).xhr();\n    } catch (e) {\n      return Promise.reject(\"get方法内部出错\" + e);\n    }\n  }\n  // 声明post静态方法\n  static post(url, options, data) {\n    try {\n      return new this(\"POST\", url, options, data).xhr();\n    } catch (e) {\n      return Promise.reject(\"post方法内部出错\" + e);\n    }\n  }\n  static jsonp(url, data) {\n    return new Promise((resolve, reject) => {\n      try {\n        // window对象绑定一个回调函数\n        const body = document.body;\n        const script = document.createElement(\"script\");\n        window[data.cb] = function (res) {\n          resolve(res); // 处理promise激活微任务\n        };\n        url = this.handleUrl(url, data); // 处理URL\n        script.src = url;\n        body.appendChild(script); // body标签后添加script标签程序自动加载内容\n        body.removeChild(script); // 获得参数后移除添加的script标签\n      } catch (e) {\n        body.removeChild(script);\n        reject(\"jsonp中发生错误\", e);\n        \n      }\n    });\n  }\n  // 异步发送\n  xhr() {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest(); // 声明网络请求对象\n      xhr.open(this.method, this.url, this.async); // 设置网络请求配置\n      xhr.responseType = this.options.responseType; // 请求数据类型\n      xhr.send(this.data); //发送参数\n      xhr.onload = function () {\n        // 请求成功后的网络执行的函数\n        if (xhr.status == 200) {\n          //状态码\n          resolve(xhr.response);\n        } else {\n          reject({ status: xhr.status, error: xhr.statusText });\n        }\n      };\n      xhr.onerror = function (error) {\n        reject(error);\n      };\n    });\n  }\n}\nexport { getByElementIds, HuaAjaxTools };\n\n// 使用实例\nimport { HuaAjaxTools } from \"../utils.js\";\n\nHuaAjaxTools.get(\n  \"http://api.tianapi.com/txapi/everyday/index\",\n  { responseType: \"json\" },\n  {\n    key: \"2cab6669e9d6766c2990eccfa3253ee5\",\n  }\n).then(\n  (result) => {\n    console.log(result);\n  },\n  (reject) => {\n    console.log(reject);\n  }\n);\n\nHuaAjaxTools.post(\n  \"http://api.tianapi.com/txapi/everyday/index\",\n  {\n    responseType: \"json\",\n    headers: {\n      \"Content-Type\": \"application/json;charset=utf-8\",\n    },\n  },\n  {\n    key: \"2cab6669e9d6766c2990eccfa3253ee5\",\n  }\n).then(\n  (result) => {\n    console.log(result);\n  },\n  (reject) => {\n    console.log(reject);\n  }\n);\n\nHuaAjaxTools.jsonp(\"https://www.baidu.com/su\", {\n  wd: \"花森\", // 参数关键值\n  cb: \"handleSuggestion\", // 回调函数\n}).then(\n  (success) => {\n    console.log(success);\n  },\n  (error) => {\n    console.log(error);\n  }\n);\n\n```\n\n### 2.fetch\n\nFETCH是JS升级后提供的更简便的网络请求的操作方法，内部使用Promise完成请求，使用response.json()接收JSON类型数据，使用response.text()接收text类型数据。\n\n#### <u>get</u>\n\n```javascript\nfetch(\n  \"http://wthrcdn.etouch.cn/weather_mini?city=%E9%87%91%E5%B7%9E%E5%8C%BA\"\n)\n  .then((res) => {\n  return res.json();\n})\n  .then((data) => {\n  console.log(data);\n});\n```\n\n#### <u>post</u>\n\n发送的JSON类型需要设置请求头为 `application/json;charset=utf-8`\n\n```javascript\nfetch(`链接`, {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json;charset=utf-8',\n  },\n  body: JSON.stringify({ name: '花森' }),\n})\n  .then((response) => {\n    return response.json()\n  })\n  .then((data) => {\n    console.log(data)\n  })\n```\n\n\n\n\n\n# 正则表达式\n\n正则表达式是用于匹配字符串中字符组合的模式，正则表达式是在宿主环境下运行，不是一门单独的语言，几乎主流语言（js/php/node.js）等都存在正则表达式语法。\n\n### 1.声明正则\n\n```javascript\n// 字面量\nlet hs = \"huasenjio\";\nconsole.log(/u/.test(hs));//true \"//\"字面量形式写法但不可以在其中使用变量\nconsole.log(/hs/.test(hs)); //false 变量形式被当做字符型去匹配\nconsole.log(eval(`/${hs}/`).test(hs)); //true 通过eval函数实现解析变量\n\n// 对象形式\nlet hs = \"huasenjio.top\";\nlet zhuqi = \".top\";\nlet reg = new RegExp(zhuqi); // 匹配规则\nconsole.log(reg.test(hs)); //true \n\n\n\n```\n\n### 2.选择符\n\n`|` 这个符号带表选择修释符，选择符左右两侧仅能匹配一个。\n\n```javascript\nlet hs = \"森酱生气了\";\nconsole.log(/(森酱|猪琦)生气了/.test(hs));\n```\n\n### 3.字符转义\n\n转义用于改变字符的含义，例如`/`在是正则符号的边界，如果想要输入网址匹配，则需要通过`\\`把`/`转移成字符串的含义。\n\n```javascript\nconst url = \"https://\";\nconsole.log(/https:\\/\\//.test(url)); //true\n```\n\n### 4.字符边界\n\n使用字符边界符用于控制匹配内容的开始与结束约定\n\n| 边界符 | 说明                        |\n| ------ | --------------------------- |\n| ^      | 匹配字符串的开始            |\n| $      | 匹配字符串的结束 忽略换行符 |\n\n```javascript\nlet hs = \"n.huasenjio.top\";\nconsole.log(/^n\\./.test(hs)); //n.打头的字符串会被匹配\n```\n\n### 5.元子字符\n\n元字符是正则表达式中的最小元素，仅代表单一一个字符。\n\n| 元字符 | 说明                                              | 示例          |\n| ------ | ------------------------------------------------- | ------------- |\n| \\d     | 匹配任意一个数字                                  | [0-9]         |\n| \\D     | 与除了数字以外的任何一个字符匹配                  | [^0-9]        |\n| \\w     | 与任意一个英文字母数字或下划线匹配                | [a-zA-Z_]     |\n| \\W     | 除了字母数字或下划线外与任何字符匹配              | [^a-zA-Z_]    |\n| \\s     | 任意一个空白字符匹配 如空格 制表符`\\t` 换行符`\\n` | [\\n\\f\\r\\t\\v]  |\n| \\S     | 除了空白符外任意一个字符匹配                      | [^\\n\\f\\r\\t\\v] |\n| .      | 匹配除换行符外的任意字符                          |               |\n\n```javascript\nlet hd = \"huasenjio 2010\";\nconsole.log(hd.match(/\\d/g)); // [\"2\", \"0\", \"1\", \"0\"]\nconsole.log(hd.match(/\\d/)); // [\"2\"]\nconsole.log(hd.match(/\\d+/)); // [\"2010\"]\n```\n\n### 6.模式修饰\n\n正则表达式在执行时会按他们的默认执行方式进行匹配\n\n| 修饰符 | 说明                                                |\n| ------ | --------------------------------------------------- |\n| i      | 不区分大小写字母的匹配                              |\n| g      | 全局搜索所有匹配内容                                |\n| m      | 视为多行                                            |\n| s      | 视为单行忽略换行符  使用`.` 可以匹配所有字符        |\n| y      | 从 `regexp.lastIndex` 开始匹配 匹配不成功就不再继续 |\n| u      | 正确处理四个字符的 UTF-16 编码                      |\n\n```javascript\n// 全域g，忽略大小写i。\nlet hd = \"huasenJIO 2010\";\nconsole.log(hd.match(/Jio \\d+/gi)); // [\"JIO 2010\"]\n\n// u配合属性别名，L表示字母，P表示标点符号，\\p{sc=Han}表示中国汉字。\nconsole.log(hd.match(/\\p{L}+ \\d+/gu)); // [\"huasenJIO 2010\"]\n\n// RegExp对象lastIndex 属性可以返回或者设置正则表达式开始匹配的位置，必须配合g模式使用，匹配完成时lastIndex会被重置为0且对exec有效。\nlet hs = `花森导航网址`;\nlet reg = /\\p{sc=Han}/gu;\nreg.lastIndex = 2; // 正则遍历的脚步\nwhile ((res = reg.exec(hs))) {\n  console.log(reg.lastIndex);\n  console.log(res[0]);\n}\n\n// y\nlet hs = \"udunren\";\nlet reg = /u/y;\nconsole.log(reg.exec(hs));\nconsole.log(reg.lastIndex); //1\nconsole.log(reg.exec(hs)); //null\nconsole.log(reg.lastIndex); //0\n```\n\n### 7.原子表\n\n在一组字符中匹配某个元字符就要将其加入`[]`中\n\n| 原子表 | 说明                                |\n| ------ | ----------------------------------- |\n| []     | 只匹配其中的一个原子                |\n| [^]    | 只匹配\"除了\"其中字符的任意一个原子  |\n| [0-9]  | 匹配0-9任何一个数字（需要升序）     |\n| [a-z]  | 匹配小写a-z任何一个字母（注意顺序） |\n| [A-Z]  | 匹配大写A-Z任何一个字母（注意顺序） |\n\n```javascript\nlet hs= \"huasenJIO 2010\";\nconsole.log(hs.match(/[hua]/g)); // [\"h\", \"u\", \"a\"] 匹配到h、u、a中任意的单个字符\n```\n\n### 8.原子组\n\n多个元子当成一个整体匹配，可以通过元子组完成，用括号`()`进行包裹。\n\n```javascript\nconst hs = `<h1>huasenjio</h1>`;\nconsole.log(/<(h1)>.+<\\/\\1>/.test(hs)); //true\n```\n\n#### <u>使用分组</u>\n\n`$n` 指在替换时使用匹配的分组数据，下面是匹配h标题标签替换成p段落标签，并引用第二个分组的数据放入。\n\n```javascript\n let hs = `\n<h1>花森酱</h1>\n<span>huasen</span>\n<h2>Jio</h2>\n`;\n// 第一个分组（h[1-6]），第二个分组（[\\s\\S]*）。\nlet reg = /<(h[1-6])>([\\s\\S]*)<\\/\\1>/gi;\nconsole.log(hs.replace(reg, `<p>$2</p>`));\n```\n\n### 9.重复匹配\n\n#### <u>基本使用</u>\n\n如果要重复匹配一些内容时我们要使用重复匹配修饰符\n\n| 符号  | 说明                       |\n| ----- | -------------------------- |\n| *     | 重复取零次或更多次（0或n） |\n| +     | 重复一次或更多次（1或n）   |\n| ?     | 重复零次或一次（0或1）     |\n| {n}   | 重复n次                    |\n| {n,}  | 重复n次或更多次            |\n| {n,m} | 重复n到m次                 |\n\n```javascript\nlet hd = \"hssss\";\nconsole.log(hd.match(/hs+/i)); //hssss\n```\n\n#### <u>禁止贪婪</u>\n\n正则表达式在进行重复匹配时，默认是贪婪匹配模式，当后面还存在符合的字符就一直贪婪匹配下去，这时就可以使用禁止贪婪，可以通过`?`进行修饰。\n\n| 使用   | 说明                           |\n| ------ | ------------------------------ |\n| *?     | 重复任意次 但尽可能少重复      |\n| +?     | 重复1次或更多次 但尽可能少重复 |\n| ??     | 重复0次或1次 但尽可能少重复    |\n| {n,m}? | 重复n到m次 但尽可能少重复      |\n| {n,}?  | 重复n次以上 但尽可能少重复     |\n\n```javascript\n// 满足表达式即可不贪婪下去\nlet str = \"1234\";\nconsole.log(str.match(/\\d+/)); //1234\nconsole.log(str.match(/\\d+?/)); //1\nconsole.log(str.match(/\\d{2,3}?/)); //12\nconsole.log(str.match(/\\d{2,}?/)); //12\n\n<h1>huasen</h1>\n<h2>花森</h2>\n<h3></h3>\n<h1></h1>\n<script>\n  let body = document.body.innerHTML;\n\tlet reg = /<(h[1-6])>[\\s\\S]*?<\\/\\1>/gi; // 禁止贪婪 [\"<h1>huasen</h1>\",\"<h2>花森</h2>\",\"<h3></h3>\",\"<h1></h1>\"]\n\tlet reg = /<(h[1-6])>[\\s\\S]*<\\/\\1>/gi; // 开启贪婪 [\"<h1>huasen</h1>↵ <h2>花森</h2>↵ <h3></h3>↵ <h1></h1>\"]\n\tconsole.table(body.match(reg));\n</script>\n```\n\n### 10.字符串方法\n\n#### <u>search</u>\n\nsearch() 方法用于检索字符串中指定的子字符串，也可以使用正则表达式搜索，返回值为索引位置。\n\n```javascript\nlet str = \"huasenjio.top\";\nconsole.log(str.search(\"top\")); // 10下标匹配到\nconsole.log(str.search(/\\.top/i)); // 9\n```\n\n#### <u>match</u>\n\n直接使用字符串搜索\n\n```javascript\nlet str = \"huasenjio.top\";\nconsole.log(str.match(\"top\")); // 返回匹配的参数\nconsole.log(str.match(/\\.top/i)); // 返回匹配的参数\n```\n\n#### <u>split</u>\n\n通过正则匹配到的符号进行字符串分割\n\n```javascript\nlet str = \"2023/02-12\";\nconsole.log(str.split(/-|\\//));\n```\n\n#### <u>replace</u>\n\n`replace` 方法不仅可以执行基本字符替换，也可以进行正则替换，下面替换日期连接符。\n\n```javascript\nlet str = \"2023/02/12\";\nconsole.log(str.replace(/\\//g, \"-\")); //2023-02-12\n```\n\n### 11.正则方法\n\n#### <u>test</u>\n\n使用正则判定字符串是否存在特定符号，检测输入的邮箱是否合法。\n\n```html\n<body>\n  <input type=\"text\" name=\"email\" />\n</body>\n\n<script>\n  let email = document.querySelector(`[name=\"email\"]`);\n  email.addEventListener(\"keyup\", e => {\n    console.log(/^\\w+@\\w+\\.\\w+$/.test(e.target.value));\n  });\n</script>\n```\n\n#### <u>exec</u>\n\n不使用 `g` 修饰符时与 `match` 方法使用相似，使用 `g` 修饰符后可以循环调用直到全部匹配完。\n\n```html\n<div class=\"content\">花森导航中的作者花森不断分享种花技巧</div>\n<script>\n  let content = document.querySelector(\".content\");\n  let reg = /(?<tag>花)/g;\n  let num = 0;\n  while ((result = reg.exec(content.innerHTML))) {\n    num++;\n  }\n  console.log(`花共出现${num}次`);\n</script>\n```\n\n### 11.断言匹配\n\n断言虽然写在扩号中但它不是组，所以不会在匹配结果中保存，可以将断言理解为正则中的条件。\n\n#### (?=exp)\n\n**零宽先行断言** `?=exp` 匹配后面为 `exp` 的内容\n\n#### (?<=exp)\n\n**零宽后行断言** `?<=exp` 匹配前面为 `exp` 的内容\n\n#### (?!exp)\n\n**零宽负向先行断言** 后面不能出现 `exp` 指定的内容\n\n#### (?<!exp)\n\n**零宽负向后行断言** 前面不能出现exp指定的内容\n\n\n\n\n\n# window对象\n\nwindow 是客户端浏览器对象模型的基类，window对象也称BOM是JavaScript的全局对象，每一个标签页就是一个独立的窗口独立的BOM对象，通过BOM对象我们可以操作当前窗口，进行进一步操作！\n\n### 1.对象分类\n\n1. Window，客户端js的顶层对象，当body和frameset标签出现时window对象就会自动创建；\n2. navigator，包含客户端浏览器的信息；\n3. screen，客户端屏幕信息；\n4. history，浏览器窗口访问过的URL信息；\n5. location，包含当前网页文档的URL信息；\n6. document，整个页面文档标签信息；\n\n### 2.系统交互\n\nwindow定义了3个人机交互的方法\n\n```javascript\nalert(\"你好\");\nconsole.log(confirm(\"你的电脑将被攻击\")); // true\nconsole.log(prompt(\"花森导航的网址为：\")); // 输入值\n```\n\n### 3.打开窗口\n\n使用 window 对象的 open() 方法可以打开一个新窗口并返回一个window对象\n\n```javascript\n//window.open (URL, name, features, replace)\nlet a = window.open(\"http://n.huasenjio.top/\", \"zhuzhu\");\nconsole.log(a); // 返回window对象\n```\n\n1. URL跳转网页的链接；\n2. name新窗口的名称，注意不是网站标题；\n3. feature声明了新窗口要显示的标准浏览器的特征；\n4. replace确定打开的网页在浏览器记录中添加一条访问记录还是替换掉原来网页中的条目；\n\n| 特征                             | 说明                                 |\n| -------------------------------- | ------------------------------------ |\n| fullscreen = yes \\| no \\| 1 \\| 0 | 是否使用全屏模式显示浏览器（默认no） |\n| height = pixels                  | 窗口文档显示区的高度                 |\n| left = pixels                    | 窗口的 x 坐标                        |\n| location = yes \\| no \\| 1 \\| 0   | 是否显示地址字段（默认是 yes）       |\n| menubar = yes \\| no \\| 1 \\| 0    | 是否显示菜单栏（默认是 yes）         |\n| resizable = yes \\| no \\| 1 \\| 0  | 窗口是否可调节尺寸（默认是 yes）     |\n| scrollbars = yes \\| no \\| 1 \\| 0 | 是否显示滚动条（默认是 yes）         |\n| status = yes \\| no \\| 1 \\| 0     | 是否添加状态栏（默认是 yes）         |\n| toolbar = yes \\| no \\| 1 \\| 0    | 是否显示浏览器的工具栏（默认是 yes） |\n| top = pixels                     | 窗口的 y 坐标                        |\n| width = pixels                   | 窗口的文档显示区的宽度               |\n\n新创建的window对象有一个opener属性指向原始的网页对象\n\n```javascript\nwin = window.open(); //打开新的空白窗口\nwin.document.write(\"<h1>这是新打开的窗口</h1>\"); //在新窗口中输出提示信息\nwin.focus(); //让原窗口获取焦点\nwin.opener.document.write(\"<h1>这是原来窗口</h1>\"); //在原窗口中输出提示信息\nconsole.log(win.opener == window); //检测window.opener属性值\n```\n\n### 4.关闭窗口\n\n关闭当前窗口，使用 window.closed 属性可以检测当前窗口是否关闭。\n\n```javascript\nwindow.close();\n```\n\n### 5.定时器\n\n| 方法            | 说明                                             |\n| --------------- | ------------------------------------------------ |\n| setInterval()   | 按照执行的周期（单位为毫秒）调用函数或计算表达式 |\n| setTimeout()    | 在指定的毫秒数后调用函数或计算表达式             |\n| clearInterval() | 取消由 setInterval() 方法生成的定时器            |\n| clearTimeout()  | 取消由 setTimeout() 方法生成的定时器             |\n\n### 6.框架集合\n\n每一个frame标签都是一个window对象，使用frame可以访问每一个window对象，frames是一个数据集合，存储者所有的window对象，下标从0开始，访问顺序从左到右从上到下，通过`parent.frames[0]`访问对应的frame框架的window对象。\n\n```javascript\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<frameset rows=\"50%,50%\" cols=\"*\" frameborder=\"yes\" border=\"1\" framespacing=\"0\">\n  <frameset rows=\"*\" cols=\"50%,*,*\" framespacing=\"0\" frameborder=\"yes\" border=\"1\">\n      <frame src=\"http://n.huasenjio.top/\" name=\"left\" id=\"left\" />\n      <frame src=\"middle.html\" name=\"middle\" id=\"middle\">\n      <frame src=\"right.html\"name=\"right\" id=\"right\">\n  </frameset>\n  <frame src=\"http://huasenjio.top/\" name=\"bottom\" id=\"bottom\">\n</frameset>\n<body>\n  \n</body>\n</html>\n```\n\n### 7.窗口大小位置\n\n方法 moveTo() 可以将窗口的左上角移动到指定的坐标，方法 moveBy() 可以将窗口上移、下移、左移、右移指定数量的像素，方法 resizeTo() 和 resizeBy() 可以按照绝对数量和相对数量调整窗口的大小。\n\n#### <u>调整窗口位置</u>\n\nmoveTo() 和 moveBy()\n\n#### <u>窗体大小</u>\n\nresizeTo() 和 resizeBy()\n\n#### <u>滚动条</u>\n\nscrollTo() 和 scrollBy()\n\n\n\n\n\n# navigator对象\n\nnavigator 对象存储了与浏览器相关的基本信息，例如名称、版本、系统信息，通过window.navigator 可以引用该对象，读取客户端基本信息。\n\n### 1.浏览器检测方法\n\n#### <u>特征检测法</u>\n\n特征检测法就是根据浏览器是否支持特定的功能来决定相应操作的非精确判断方式，但却是最安全的检测方法，仅仅在意浏览器的执行能力，那么使用特征检测法就完全可以满足需要。\n\n```javascript\n// 检测当前浏览器是否支持 document.getElementsByName 特性，不支持则使用document.getElementsByTagName 特性，进行兼容处理。\nif (document.getElementsByName) {  //如果存在则使用该方法获取a元素\n    var a = document.getElementsByName (\"a\");\n} else if (document.getElementsByTagName) {  //如果存在则使用该方法获取a元素\n    var a = document.getElementsByTagName (\"a\");\n}\n```\n\n#### <u>字符串检测法</u>\n\n客户端浏览器每次发送 HTTP 请求时，请求头中有一个user-agent（用户代理）属性，使用用户代理字符串检测浏览器类型，可以通过`navigator.userAgent`获取客户端信息。\n\n```javascript\nvar s = window.navigator.userAgent;\n//简写方法\nvar s = navigator.userAgent;\nconsole.log(s);\n//返回类似信息：Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36\n```\n\n### 2.检测版本号\n\n获得客户端信息后通过正则表达式筛选对应信息即可\n\n\n\n\n\n# location对象\n\nlocation 对象存储了当前文档位置（URL）相关的信息，例如网页的地址，访问历史信息，可以通过`window.location`进行访问，location中定义有一下8个属性：\n\n### 1.对象属性\n\n| 属性     | 说明                                                         |\n| -------- | ------------------------------------------------------------ |\n| href     | 声明了当前显示文档的完整 URL（设置可以利用网页跳转）         |\n| protocol | 声明了 URL 的协议部分（例如：“http:”）                       |\n| host     | 声明了当前 URL 中的主机名和端口部分（例如：“huasenjio.top:80”） |\n| hostname | 声明了当前 URL 中的主机名                                    |\n| port     | 声明了当前 URL 的端口部分                                    |\n| pathname | 声明了当前 URL的路径部分                                     |\n| search   | 声明了当前 URL 的查询部分（例如：“?id=123&name=location”）   |\n| hash     | 声明了当前 URL 中锚部分（“#top”指定在文档中锚记的名称）      |\n\n### 2.对象方法\n\n#### <u>reload</u>\n\n可以重新装载当前文档\n\n#### <u>replace</u>\n\n可以装载一个新文档而无须为它创建一个新的历史记录，即不能通过单击“返回”按钮返回当前的文档，`window.location`和`document.location`不同，前者是location对象，后者是一个只读字符串，当服务器发生重定向，document.location 包含的是已经装载的 URL，而 location.href 包含的则是原始请求文档的 URL。\n\n\n\n\n\n# history对象\n\nhistory 对象存储了库互动浏览器的浏览历史，通过`window.history`可以访问对象，取到最近访问且有限的条目URL信息。HTML5 之前，为了保护客户端浏览信息的安全和隐私，history 对象禁止`javascript`脚本直接操作这些访问信息。HTML5 新增了一个 History API，该 API 允许用户通过 JavaScript 管理浏览器的历史记录，实现无刷新更改浏览器地址栏的地址。\n\n### 1.基本操作\n\n```javascript\nwindow.history.back();1// 历史记录中后退，等效于在浏览器的工具栏上单击“返回”按钮。\nwindow.history.forward();1 // 历史记录中前进，等效于浏览器中单击“前进”按钮。\nwindow.history.go(1);  // 移动到指定的历史记录点\nwindow.history.length; // 访问记录长度\nwindow.history.state; // 当前标签的访问记录\n```\n\n### 2.添加修改\n\nHTML5 新增 history.pushState() 和 history.replaceState() 方法，允许用户逐条添加和修改历史记录条目。\n\n#### <u>pushState</u>\n\npushState可以修改referer值，调用该方法后创建的 XMLHttpRequest 对象会在 HTTP 请求头中使用referer值，referrer 的值则是创建 XMLHttpRequest 对象时所处的窗口的 URL。 pushState() 方法类似于设置 window.location='#foo'，它们都会在当前文档内创建和激活新的历史记录条目，pushState() 方法永远不会被触发 hashchange 事件，因为没有记录被删除或者被添加，push进行修改当前的历史条目且不刷新网页。\n\n```javascript\nvar stateObj = {foo : \"bar\"};\nhistory.pushState (stateObj, \"标题\", \"bar.html\"); // 当前标签URL变为XXX/bar.html\n```\n\n#### <u>replaceState</u>\n\nhistory.replaceState() 与 history.pushState() 用法相同，pushState() 是在 history 栈中添加一个新的条目，replaceState() 是替换当前的记录值。\n\n### 3.popstate事件\n\n每当激活的历史记录发生变化时，都会触发 popstate 事件。如果被激活的历史记录条目是由 pushState() 创建，或者是被 replaceState() 方法替换的，popstate 事件的状态属性将包含历史记录的状态对象。\n\n\n\n\n\n# screen对象\n\nscreen 对象存储了客户端屏幕信息，可以用来探测客户端硬件配置，实现根据显示器屏幕大小选择使用图像的大小，根据颜色深度选择使用 16 色图像或 8 色图像。\n\n```javascript\nfunction center(url) {\n  //窗口居中处理函数\n  var w = screen.availWidth / 2; //获取客户端屏幕宽度的一半\n  var h = screen.availHeight / 2; //获取客户端屏幕高度的一半\n  var t = (screen.availHeight - h) / 2; //计算居中显示时顶部坐标\n  var l = (screen.availWidth - w) / 2; //计算居中显示时左侧坐标\n  var p = \"top=\" + t + \",left=\" + l + \",width=\" + w + \",height=\" + h; //设计坐标参数字符串\n  var win = window.open(url, \"url\", p); //打开指定的窗口，并传递参数\n  win.focus(); //获取窗口焦点\n}\nconsole.log(screen);\ncenter(\"http://huasenjio.top\"); //调用该函数\n```\n\n\n\n\n\n# document对象\n\n浏览器加载文档会自动构建文档对象模型（DOM），文档中每个元素都映射到一个数据集合。\n\n![DwE14edR39VUBZI](https://s2.loli.net/2022/05/19/DwE14edR39VUBZI.png)\n\n\n\n### 1.动态生成文档内容\n\n使用 document 对象的 write() 和 writeln() 方法可以动态生成文档内容\n\n#### <u>write()</u>\n\n生成内容追加在文档树的末尾\n\n```javascript\ndocument.write ('Hello,World');\n```\n\n#### <u>writeln()</u>\n\nwriteln() 方法与 write() 方法完全相同，只不过在输出参数之后附加一个换行符。\n\n\n\n\n\n# XMLHttpRequest\n\n`XMLHttpRequest`（XHR）对象用于与服务器交互，通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，更新页面的局部内容。\n\n### 1.定义声明\n\n构造函数用于初始化一个 `XMLHttpRequest` 实例对象\n\n```javascript\nlet xhr = new XMLHttpRequest();\n```\n\n### 2.属性类型\n\n| XMLHttpRequest对象属性 | 说明                                               |\n| ---------------------- | -------------------------------------------------- |\n| onreadystatechange     | 根据readyState属性发生变化调用方法                 |\n| readyState             | 发送请求进程状态分为（0\\|1\\|2\\|3\\|4完成）          |\n| response               | 服务器返回的数据类型                               |\n| responseText           | 返回文本数据                                       |\n| responseType           | 定义服务器响应类型                                 |\n| responseURL            | 返回经过序列化（serialized）的响应 URL             |\n| responseXML            | 返回XML格式数据                                    |\n| status                 | 代表服务器响应的状态码                             |\n| statesText             | 包含完整的响应状态文本（例如\"`200 OK`\"）           |\n| unload                 | 上传进度                                           |\n| timeout                | 请求的最大请求时间（毫秒）超出自动终止             |\n| withCreadtials布尔值   | 指定跨域 `Access-Control` 请求是否应当带有授权信息 |\n\n### 3.常用方法\n\n| XMLHttpRequest.方法     | 说明                                                         |\n| ----------------------- | ------------------------------------------------------------ |\n| abort()                 | 立即终止请求                                                 |\n| getAllResponseHeaders() | 字符串的形式返回所有用 [CRLF](https://developer.mozilla.org/zh-CN/docs/Glossary/CRLF) 分隔的响应头 |\n| getResponseHeader()     | 返回包含指定响应头的字符串                                   |\n| open()                  | 初始化一个请求                                               |\n| overrideMimeType        | 覆写由服务器返回的 MIME 类型                                 |\n| send()                  | 发送请求                                                     |\n| setRequestHeader()      | 设置 HTTP 请求头的值（open之后且send()之前设置）             |\n\n### 4.事件监听\n\n| addEventListener监听 | 说明                           |\n| -------------------- | ------------------------------ |\n| abort                | 当 request 被停止时触发        |\n| error                | 当 request 遭遇错误时触发      |\n| load                 | 请求成功完成时触发             |\n| timeout              | 预设时间内没有接收到响应时触发 |\n\n### 5.简单示例\n\n```javascript\nlet xhr = new XMLHttpRequest();\n// 开启请求任务 readyState=0\nxhr.open(\n  \"GET\",\n  \"http://wthrcdn.etouch.cn/weather_mini?city=%E9%87%91%E5%B7%9E%E5%8C%BA\"\n);\nxhr.send(); //发送请求 readyState=1\n\n// 监听readyState变化来等待服务器响应\nxhr.onreadystatechange = function () {\n  if (xhr.readyState == 4 && xhr.status == 200) {\n    console.log(\"获取数据：\" + xhr.responseText); // readyState=4\n  } else {\n    console.log(\"readyState：\" + xhr.readyState); // readyState=2  readyState=3\n  }\n};\n// 请求成功回调\nxhr.addEventListener(\"load\", () => {\n  console.log(\"请求成功会触发事件！\");\n});\n```\n\n### 6.XMLHttpRequest2新特性\n\n旧版本只支持文本格式传输，无法用于读取上传二进制文件，接收和传送时无法查看进度信息，不能跨域请求，第二版本优化功能具有一下特点：\n\n1. 设置HTTP请求的时限；\n2. 可以使用FormData对象管理表单数据；\n3. 上传文件；\n4. 可以请求不同域名下的数据（跨域请求）；\n5. 获取服务器端的二进制数据；\n6. 可以获得数据传输的进度信息；\n\n#### <u>formData</u>\n\najax操作往往用来传递表单数据，所以HTML5新增了一个FormData对象，可以模拟表单数据。\n\n```javascript\n// 实例化对象\nvar formData = new FormData(); \n// 添加表单项\nformData.append('username', '张三');\nformData.append('id', 123456);\n// 发送格式\nxhr.send(formData);\n```\n\n#### <u>上传文件</u>\n\n新版XMLHttpRequest对象可以上传文件，假定files是一个\"选择文件\"的表单元素`（input[type=\"file\"]）`，我们同样使用formData格式进行传输。\n\n```javascript\nvar formData = new FormData();\n\nfor (var i = 0; i < files.length;i++) {\n\n  formData.append('files[]', files[i]);\n\n}\n\nxhr.send(formData);\n```\n\n#### <u>接收二进制数据</u>\n\n服务器取回二进制数据是使用新增的responseType属性，如果服务器返回文本数据则属性值为”text“，不要用IE6这种古董浏览器还可以支持其他格式数据，例如设置传回属性是json字符串格式。\n\n```javascript\nvar xhr = new XMLHttpRequest();\nxhr.open('GET', 'http://wthrcdn.etouch.cn/weather_mini?city=%E9%87%91%E5%B7%9E%E5%8C%BA');\nxhr.responseType: \"json\",\nxhr.send();\nxhr.onreadystatechange = function () {\n  if (xhr.readyState == 4 && xhr.status == 200) {\n    console.log(xhr.response); // readyState=4\n  } else {\n    console.log(\"readyState：\" + xhr.readyState); // readyState=2  readyState=3\n  }\n};\n```\n\n#### <u>进度信息</u>\n\n新版本的XMLHttpRequest对象在传输数据时可以通过监听progress事件用来返回进行信息，它分成上传下载情况，下载的progress事件属于XMLHttpRequest对象，上传的progress事件属于XMLHttpRequest.upload对象。\n\n```javascript\nxhr.onprogress = 方法;\nxhr.upload.onprogress = 方法;\n\n// 实例\nxhr.onprogress = function (event) {\n  console.log(event);\n  if (event.lengthComputable) {\n    var percentComplete = event.loaded / event.total;\n  }\n};\n```\n\n\n\n\n\n# HTTP请求头\n\nHTTP协议报文头部由方法、URL、HTTP版本、HTTP首部字段等部分构成，携带报文主题大小，使用语言，认证信息详细信息。\n\n### 1.首部字段类型\n\n1. 通用首部字段；\n2. 请求首部字段；\n3. 响应首部字段；\n4. 实体首部字段；\n\n### 2.通用首部字段\n\n| 通用首部字段     | 说明                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| Cache-Control    | 控制缓存行为（no-cache\\|max-age\\|public）                    |\n| Connection       | 连接状态管理（close\\|Keep-Alive\\|timeout max=500）           |\n| Date             | HTTP/1.1协议使用RFC1123中规定的日期时间的格式                |\n| Pragma           | 客户端要求中间服务器不返回缓存资源（Pragma:no-cache）        |\n| Trailer          | 简要记录主体报文记录首部字段（）                             |\n| Trailer-Encoding | 规定了传输报文主体时使用的编码方式                           |\n| Upgrade          | 用于检测HTTP协议及其他协议是否可以使用更高的版本进行通信（TLS/1.0） |\n| Via              | 追踪客户端与服务端之间的请求和响应报文的传输路径             |\n| Warning          | 错误通知(110响应过期\\|112断开连接\\|)                         |\n\n### 3.请求首部字段\n\n| 首部字段名          | 说明                                                         |\n| ------------------- | ------------------------------------------------------------ |\n| Accept*             | 用于代理可处理的媒体类型                                     |\n| Accept-Charset      | 通知服务器用户代理支持的字符集及字符集的相对优先级顺序       |\n| Accept-Language     | 告知服务器用户代理能够处理的自然语言集以及自然语言集的相对优先级 |\n| Accept-Encoding*    | 通知服务器用户代理支持的内容编码及内容编码的优先级顺序       |\n| Authorization       | 告知服务器用户代理的认证信息                                 |\n| Expect              | 期待服务器的特定行为                                         |\n| From                | 告知服务器使用代理的用户的电子邮件地址                       |\n| Host                | 请求的资源所处的互联网主机名和端口号                         |\n| If-Mach             | 条件请求（比较实体标记（ETAG）相同才可以请求）               |\n| If-Modified-Since   | 用于确认代理或客户端拥有的本地资源的有效性（304缓存）        |\n| If-None-Match       | 相反比较实体标记                                             |\n| Max-Forwads         | 字段以十进制整数形式指定可经过的服务器最大数目               |\n| Proxy-Authorization | 客户端接收到从代理服务器发送过来的认证质询（返回时提交必要信息） |\n| Range               | 客户端发送带有该首部字段的请求可以指定服务器资源的范围       |\n| User-Agent          | 创建请求的浏览器和用户代理名称等信息传达给服务器             |\n| If-Range            | 资源未更新是发送实体Byte的范围请求                           |\n| If-UNmodified-Since | 相反的比较更新时间                                           |\n| Referer             | 告知服务器请求的原始资源的URI                                |\n| TE                  | 首部字段会告知服务器客户端能够处理响应的传输编码方式以及相对优先级 |\n\n### 4.响应首部字段\n\n| 响应首部字段     | 说明                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| Accept-Ranges    | 是否接受字节范围请求                                         |\n| Age              | 推算资源创建经过时间                                         |\n| Etag             | 告知客户端实体标识（可将资源以字符串形式做唯一性标识）       |\n| Location         | 命令客户端重定向至指定URL                                    |\n| Retry-After      | 首部字段告知客户端应该在多久之后再次发送请求                 |\n| Server           | 首部字段告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息 |\n| Vary             | 源服务器会向代理服务器传达关于本地缓存使用方法的命令         |\n| WWW-Authenticate | 首部字段用于 HTTP 访问认证                                   |\n\n### 5.实体首部字段\n\n| 实体首部字段     | 说明                                                     |\n| ---------------- | -------------------------------------------------------- |\n| Allow            | 首部字段用于通知客户端能够支持指定资源的所有 HTTP 方法   |\n| Content-Encoding | 告知客户端服务器对实体的主体部分选用的内容编码方式       |\n| Content-Language | 告知客户端实体主体使用的自然语言                         |\n| Content-Length   | Content-Length 表明了实体主体部分的大小                  |\n| Content-Location | 首部字段给出与报文主体部分相对应的 URI                   |\n| Content-MD5      | MD5 算法生成的值目的是检查报文主体在传输过程中是否保持完 |\n| Content-Range    | 告知客户端作为响应返回的实体                             |\n| Content-Type     | 首部字段说明了实体主体内对象的媒体类型                   |\n| Expires          | 资源失效的日期告知客户端                                 |\n| Last-Modified    | 首部字段指明资源最终修改的时间                           |\n\n### 6.服务Cookie的首部字段\n\n属于响应首部字段，用于服务端开始管理客户端状态的交互的载体。\n\n| 属性         | 说明                                       |\n| ------------ | ------------------------------------------ |\n| NAME=VALUE   | 赋予Cookie的名称和值                       |\n| expires=DATE | Cookie有效期（不指明则默认为浏览器关闭时） |\n| path=PATH    | 服务器上的文件目录作为Cookie的适用对象     |\n| domain=域名  | 作为Cookie适用对象的域名                   |\n| Secure       | 仅在HTTPS安全通信时才会发生Cookie          |\n| HttpOnly     | 限制Cookie不能被JavaScript脚本访问         |",
      "isDraft": "false",
      "publisher": "932397243@qq.com",
      "tag": "javascript/记录/教程/文档",
      "time": "2022-5-19",
      "title": "JavaScript小黄书"
    },
    {
      "bannerImg": "huasen-public-static/admin/1650133538333.png",
      "code": "0",
      "content": "# 缓存简述\n\n### 1.概念\n\n每当我们输入网址时浏览器负责通过http协议向服务器请求获取数据，缓存可以缩短请求时间，节省带宽，对于缓存文件重复利用，利用缓存机制可以提升优化性能和体验。请求资源可以分为如下三步：发起网络请求，后端服务器处理，浏览器响应。缓存则是在第一次请求时将请求到的资源进行本地保存，下次发起同样请求时如果缓存策略判定本地资源和服务器资源一致，则浏览器直接读取缓存资源渲染给用户。\n\n### 2.缓存位置\n\n1. ServerWorker是运行在浏览器背后的独立线程，用于实现缓存功能，使用ServerWorker时传输协议必须是HTTPS，可以自由控制缓存文件，如何匹配，并且缓存资源是带有持续性；\n2. MemoryCache内存缓存，文件储存于内存读取较快，但是缓存持续时间短，进程标签页被关闭时内存中的缓存将被释放；\n3. DiskCache硬盘缓存，读取数据较慢，根据HTTP请求头字段判定资源是否缓存；\n4. PushCache推送缓存，属于HTTP/2规范内容；\n\n### 3.请求缓存场景\n\n浏览器和服务器的通信方式是应答模式，是否有这样的疑惑，浏览器发起HTTP请求时如何确定资源是否已经缓存，如何进行缓存？解惑的具体流程：\n\n![LkNhwi4EJfePtBl](https://s2.loli.net/2022/05/19/LkNhwi4EJfePtBl.png)\n\n每次请求资源都会优先查询浏览器是否存在缓存，存在则查看缓存标识信息；每次从服务器请求到资源后都会将资源建立缓存，所以浏览器的缓存机制是关键。\n\n\n\n\n\n# 缓存分类\n\n### 1.强缓存\n\n不向服务器发送请求，直接读取缓存资源，打开F12控制台NetWork可以查看请求资源对于的信息`status code:200 （from memory cache）`，强缓存可以通过`Expires和Cache-Control`进行实现。\n\n#### <u>Expires</u>\n\n缓存过期时间，字段信息来源于服务器的响应头，`Expires=max-age+请求时间`，服务器响应告诉浏览器在Expires过期之前不需要请求服务器，直接请求缓存资源。\n\n#### <u>Cache-Control</u>\n\nHTTP/1.1中，Cache-Control是最重要的规则，用于控制网页缓存，设置`Cache-Control:max-age=300`代表资源五分钟内同样的资源请求直接命中缓存资源，不需要请求服务器，属于命中强缓存，Cache-Control存在与请求头和响应头，并且可以组合使用指令，具有一下指令规则：\n\n| 指令         | 作用说明                                             |\n| ------------ | ---------------------------------------------------- |\n| public       | 表示资源响应过程中可以被客户端和代理服务器缓存       |\n| private      | 资源响应式仅客户端浏览器可以缓存                     |\n| max-age=30   | 资源缓存时间30毫秒（过期需要重新请求）               |\n| s-maxage=30  | 仅在代理服务器中生效（优先级大于max-age）            |\n| no-store     | 不缓存任何响应资源                                   |\n| no-cache     | 资源可被缓存但需要同服务器上一致                     |\n| min-fresh=30 | 30毫秒内若资源过期则请求新资源（容忍最小新鲜度）     |\n| max-stale=30 | 30毫秒内若资源过期则同样适用缓存（容忍最大过期时间） |\n\n1. public，资源响应过程中经过的所有节点都可以缓存资源。很多时候资源会经过很多代理服务器（proxy），如果设置public值，请求资源时proxy服务器上的资源未失效则会直接返回给客户端；\n2. private，资源内容仅客户端可以缓存，Cache-Control的默认值，中间proxy服务器不会缓存，仅作为转发功能；\n3. no-cache，通过协商缓存来验证是否使用本地缓存资源；\n4. max-age，表示缓存资源失效时间；\n5. s-maxage，仅在代理服务器中生效，表示资源失效时间；\n6. max-stale=30，容忍的最大过期时间，表示客户端愿意接收一个30秒内被修改的过期文件；\n7. min-fresh=30，容忍的最小新鲜度，表示客户端不接收30秒内被修改的过期文件；\n\nCache-Control优先级高于Expires，Expires是远古时代的产物，现在常用于兼容写法，强缓存依赖于时间，而且精度也只能是毫秒级。如果服务器和客户端时间不一致则会导致缓存失效的问题。\n\n### 2.协商缓存\n\n当强缓存失效后就进行协商缓存，浏览器向服务器发送携带缓存标识（Etag和last-modified）的网络请求时，服务器会根据缓存标识处理，如果协商缓存生效则存在两个场景，304和NotModified两种情况；协商失败则返回200状态码和新请求的资源。\n\n#### <u>Last-Modified和If-Modified-Since</u>\n\n第一次请求支援时，服务器返回资源的同时，响应头中添加Last-Modified属性，表示服务器最后修改的时间，浏览器对资源文件进行缓存和响应头进行保存。下次请求时，浏览器检测到缓存中存在Last-Modified属性，于是在请求头中添加If-Modified-Since属性，这个属性值就是Last-Modified，服务器拿到If-Modified-Since进行比对，转换为时间戳，如果小于最后修改时间，则说明文件存在更新，返回200状态码和新的资源；如果没有更新则返回304和空的响应体，浏览器则直接从缓存读取。\n\n![d7VPxbWgzaGlAn5](https://s2.loli.net/2022/05/19/d7VPxbWgzaGlAn5.png)\n\nLast-Modified存在如下弊端：\n\n1. 如果本地打开缓存文件即使没有修改也会造成Last-Modified变动，服务器匹对不上则导致返回相同的资源；\n2. 时间精度到秒，无法感知短时间内被修改的文件；\n\n#### <u>ETag和If-None-Match</u>\n\nEtag是服务器为当前资源建立唯一标识符，资源发生变动则Etag将会重新生成。浏览器请求资源时，服务器返回的响应头中存在Etag属性，下一次浏览器再次发起请求则会在请求头中添加If-None-Match属性且值为Etag，服务器检测到Etag并用于检测是否发生变化，如果发生变化则返回200和新的资源，否则返回返回304通知浏览器直接使用缓存的资源文件。\n\n![XlYgRyPBD95xoCm](https://s2.loli.net/2022/05/19/XlYgRyPBD95xoCm.png)\n\nLast-Modified和Etag相比较不难发现，Etag在精度上优于Last-Modified，但在性能上Etag逊色于Last-Modified，若两者同时存在则优先考虑Etag。\n\n\n\n\n\n# 缓存机制\n\n强制缓存优先于协商缓存进行，协商缓存由服务器决定是否使用缓存，协商失败则请求新的资源文件，协商成功则返回304通知客户端使用本地缓存资源。\n\n![nApowgdRjJNZuv5](https://s2.loli.net/2022/05/19/nApowgdRjJNZuv5.png)\n\n\n\n\n\n# 未设置缓存\n\n如果什么缓存都没设置则浏览器会采用一个启发式的算法，通常取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。\n\n\n\n\n\n# 设置场景\n\n1. 频繁变动资源，使用Cache-Control:no-cache，每次请求都将进行协商缓存；\n2. 不常变化资源，`Cache-Control: max-age=31536000`设置一个超长的缓存时间，当请求相同URL被强缓存命中，文件名处添加打包后的hash值，解决资源变动而浏览器不请求的问题；",
      "isDraft": "false",
      "publisher": "932397243@qq.com",
      "tag": "缓存策略/强缓存/协商缓存/304",
      "time": "2022-5-19",
      "title": "浏览器缓存策略"
    },
    {
      "bannerImg": "huasen-public-static/admin/1650137855230.png",
      "code": "0",
      "content": "## 互联网\n\n计算机网络是由通信介质将地理位置不同的且相互独立的计算机连接起来，实现数据通信与资源共享。场景化分析，假设有A，B两个蜘蛛网彼此独立，同在一个网上的蜘蛛是可以相互通信，蜘蛛网和蜘蛛网之间需要通过某种规定（协议）通讯交换资源。\n\n\n\n\n\n## 因特网构成和网络分类\n\n### 1.组成概念\n\n因特网工作设备有主机，服务器，路由器，交换机，信号发射器，边缘部分。通过交换机连接电脑形成一个个子网，进而路由器连接零散的子网，分组转发消息，计算机之间交换数据，主机对交换数据进行信息处理呈现的。\n\n![SRqJtVIlZMTe8Hr](https://s2.loli.net/2022/05/19/SRqJtVIlZMTe8Hr.png)\n\n### 2.网络连接方式\n\n1. 主机直接通过电路相连，但是传输效率不高，合适传输要求延时抖动小的实时数据；\n2. 采用以交换机为中心连接，无需建立连接即可通讯；\n3. 新型网络连接，组建子网，通过路由器转发资源，共享连接在网络上的数据资源；\n\n### 3.网络分类\n\n1. 局域网，小型网络，一个公司，一个学校，一个家庭的网络设备组建的网络成为局域网，一般公司共用的wifi，学校校园网wifi，家庭wifi都是一个个局域网，同属于一个局域网内可以相互通信；\n2. 城域网，中型网络，一个地区，一个城市中的各个局域网连接起来组建成为城域网，一般一个市区的网络就是一个城域网；\n3. 广域网，大型网络，一个国家，一个国家中各个城域网连接组建称为的网络称为广域网，一般一个国家就是一个大型的广域网，我们正常不能直接访问别人国家的网络，因为伟大的祖国限制，如果需要访问外国网站借助第三方技术，俗称翻墙；\n\n### 4.网络常用拓扑\n\n1. 总线型，常用于局域网入网；\n2. 星型和树型，常用于局域网，操作相对简单；\n3. 环型，常用于城域网，无中心依赖，有较强的灵活性和自愈能力，出现故障后能够快速定位并进行保护倒换，拓展困难；\n4. 格型，主要用于骨干网、广域网，灵活性和自愈能力较好，设计复杂；\n\n![x7CS9iRnhBVrg1T](https://s2.loli.net/2022/05/19/x7CS9iRnhBVrg1T.jpg)\n\n\n\n## 性能指标和协议设计\n\n### 1.协议\n\n简而言之，协议就是一种约定，我们国家有很多民族，各个民族的语言不同，彼此间不可交流，所以引入普通话，各个民族可以通过普通话进行交流，每个网络传输的方式语言可能不同，所以需要通过协议来规约协调通讯。\n\n### 2.要素\n\n1. 时序，实现顺序和速度匹配的详细说明；\n2. 语法，数据与控制信息的结构和编码等；\n3. 语义，发出控制信息，完成动作并做出特定的响应；\n\n### 3.数据传输格式\n\n报文格式是PPP帧格式，带有标志字段，地址字段，控制字段，协议字段，信息字段等数据信息。\n\n![X7Fehb2VMz9KrJs](https://s2.loli.net/2022/05/19/X7Fehb2VMz9KrJs.png)\n\n### 4.协议模型设计\n\n互联网协议分布设计有多种，osi七层模型，tcp/ip五层模型，tcp/ip四层模型，现在用途最广泛的模型就是五层协议模型，所以我们理解它就可以明白计算机底层通讯的原理，每一层都运行着一个特定的协议，共同组成互联网协议。\n\n![rtU9wYFhMDEbBsl](https://s2.loli.net/2022/05/19/rtU9wYFhMDEbBsl.png)\n\n\n\n\n\n\n\n## 物理层\n\n物理层主要通过双绞线，光纤，电缆，无线电波传输，信息传递的本质就是高电压(1)，低电压(0)的电信号，通过调制解调器进行转化成为信号，最后通过传媒媒介进行传播。\n\n![mvwiRbl518Y46ZL](https://s2.loli.net/2022/05/19/mvwiRbl518Y46ZL.png)\n\n### 1.常用术语\n\n1. 码元，表示数字信号时代表不同离散值的基本波形；\n2. 信号，数据表现转化为电信号或者电磁形态；\n3. 数据，运送的信息实体；\n\n### 2.信道\n\n1. 单工通信，仅可以单方向传输；\n2. 半双工通信，双方交替通信，但是不可以同时发送；\n3. 全双工通信，双方可以同时发送接收；\n\n### 3.传播介质\n\n#### <u>导向性</u>\n\n1. 双绞线；\n2. 光纤和光缆；\n3. 同轴电缆；\n\n#### <u>非导向性</u>\n\n1. 地面基站微波通讯；\n2. 卫星微波通讯；\n\n### 4.信道传输速率\n\n1. 香农定理，有噪声信道信息传递速率公式；\n2. 奈式准则，无噪声信道数据传输速率公式；\n\n\n\n\n\n\n\n## 数据链路层\n\n物理层发送接收0和1是无意义的行为，例如：QQ中想给女朋友发送一句：“你是头猪！”随之转变成为0和1的比特流交给网卡，网卡直接懵圈。因为无目的地址和接收人信息，消息想要发送成功则需要通过以太网协议，需要解决介质访问控制和寻址的问题。\n\n### 1.以太网协议（CSMA/CD）\n\n以太网协议通过交换机或者集线器将电脑连接，使用广播信道发送MAC帧，其中帧分为：单播（一对一），广播（一对多），多播（多对多），帧数据格式如下：\n\n![DKB1Rk2nqOm86xX](https://s2.loli.net/2022/05/19/DKB1Rk2nqOm86xX.png)\n\n每一个MAC帧由报头（head）和和数据（data）两部分组成，其中报头固定18个字节，发送者地址个接受者地址均为6个字节，数据域最短46字节，最长1500字节。MAC帧中的目的地址和原地址所指的是MAC地址，MAC地址是网卡唯一的物理地址，网卡被生产时就烧录一串12位16进制码在卡里。通过MAC地址可以寻找到对应的电脑，发送数据帧到交换机，交换机默认会发送广播类型的数据帧，广播就相当于给所有连接的电脑发送数据帧，每一个电脑都将响应一个单播传回交换机，所以交换机记住连接电脑网卡的MAC地址。\n\n\n\n![XQGVzKsj5kuPFxv](https://s2.loli.net/2022/05/19/XQGVzKsj5kuPFxv.png)\n\n#### <u>网络适配器（网卡）</u>\n\n串行/并行在计算机内部，具有简单的数据缓存，实现以太网协议，网卡是操作系统设备驱动程序，为系统高级协议栈提供服务。\n\n#### <u>交换机</u>\n\n按道理说电脑跟电脑直接连接网线（集线器）就可以相互通讯，但是大多数电脑仅有一个网卡，那么一台电脑仅能连接一台电脑，所以引入交换机，交换机就是负责将局域网的电脑相互连接，通过以太网协议中的MAC地址，交换机就能确定一台电脑的网口，电脑信息资源通讯均需要通过网口，传输数据。\n\n![XJMmr3SLwCgVAy1](https://s2.loli.net/2022/05/19/XJMmr3SLwCgVAy1.png)\n\n\n\n显而易见，广播方式十分原始，基本通讯就是类似于靠拿着大喇叭喊话，连接交换机在同一台交换机的电脑懂能够听到，但是这些电脑默认屏蔽不关于自己的话。场景化分析一下，电脑a想给电脑b发送一个报文，报文中写有电脑b的mac地址，此时通过交换机发送给每一个连接在交换机上的电脑，电脑b发现该报文是关于自己则接收，其他电脑默认屏蔽。如果把全世界的电脑都连在一个局域网下，那么一个人发消息，这个消息就会发送给64亿台电脑，网络会瞬间瘫痪，这个现象叫做广播风暴。所以需要引入城域网，广域网的概念！\n\n![i8UDpT3ads4WRhX](https://s2.loli.net/2022/05/19/i8UDpT3ads4WRhX.png)\n\n### 2.面向连接（PPP协议）\n\n点对点面向连接协议，使用最广泛的数据链路层协议，主机拨号接入因特网一般都是使用PPP协议，PPP协议由链路控制协议LCP和网络控制协议NCP构成。用户拨号接入ISP，路由器调制解调器确认拨号报文并建立物理连接，用户主机向路由器发送LCP分组的PPP帧，路由接收处理，网络层配置，NCP为主机分配一个临时的IP地址，使用户主机成为因特网上的主机。家庭的路由器一般内置PPP协议，安装人员进行拨号入网，验证通过后你才可以使用WIFI并联网使用！\n\n![8IjQlbPp2xaoqOK](https://s2.loli.net/2022/05/19/8IjQlbPp2xaoqOK.png)\n\n\n\n## 网络层\n\n相互独立的局域网之间是不可以直接通信，需要通过路由器进行连接转发，路由器通过IP地址查找到对应的子网下的计算机，网络层IP协议需要几个辅助协议，几个协议的功能和名称如下：\n\n1. 地址解析协议ARP，负责通过IP获取到网卡的MAC地址；\n2. 逆地址解析协议RARP，负责通过MAC获取IP地址；\n3. 网际控制报文协议ICMP，检测网络故障报文；\n4. 网际组管理协议IGMP；\n\n\n\n### 1.路由器\n\n交换机组建局域网，研究MAC地址，路由器负责组建广域网，研究IP地址。路由器可以根据IP网段查找对应的子网，路由器通过路由表寻址，路由器与相邻连接的路由器连接时会告诉对方掩码信息。\n\n\n\n![ENkde2QuJPG6ZDF](https://s2.loli.net/2022/05/19/ENkde2QuJPG6ZDF.png)\n\n### 2.IP地址\n\n目前普遍使用IPV4协议，其中规定，一个网络地址由32位二进制组成，32位平均分成四份，一个份8位二进制，一个部分所能表示0-255的数值，一个IP地址分为两个部分：网络号和主机号，网络号决定地址，主机号决定计算机。\n\n### 3.子网掩码\n\n掩码和IP地址相似，32位二进制表示，子网掩码也分为网络部分和主机部分，网络部分由`1`构成，主机部分由`0`构成，子网掩码用于判断IP是否属于一个局域网（网关或者网段），如果存在于一个局域网内则直接通讯，如果不在用一个局域网则会经过路由器转发到对应的网段。根据子网掩码和IP地址可以通过`与`运算得到网关地址。\n\n```text\nIP1: 172.13.4.58\nIP2: 172.13.4.90\n\n子网掩码均为：255.255.255.0（24位掩码）\n\nIP1：172.13.4.58\n10101100 00001101 00000100 00111010\n子网掩码：\n11111111 11111111 11111111 00000000\n&运算结果：\n10101100 00001101 00000100 00000000（172.13.4.0）\n\nIP1：172.13.4.90\n10101100 00001101 00000100 01011010\n子网掩码：\n11111111 11111111 11111111 00000000\n&运算结果：\n10101100 00001101 00000100 00000000（172.13.4.0）\n```\n\n计算结果得到相同的局域网（网段）内，可以直接进行通讯，不需要出网关经过路由器跳入其他子网。因为相互通讯的计算机属于同一局域网！\n\n### 4.ARP协议\n\n存在于数据链路层和网络层之间的协议，ARP基于广播网络，解决IP地址到MAC地址之间映射关系（局域网上主机或者路由器中IP地址和MAC地址映射关系），每个使用IP的主机都存在一个ARP高速缓存协议，如果主机A想要向局域网内主机b通信，如果主机A中未存在主机b的MAC地址，则主机a进行广播ARP报文给连接的所有主机，主机b发现a发送的ARP报文中带有自己的IP，所以回应a主机一个单播并携带MAC地址，a主机将存入b主机的MAC主机，a主机和b主机开始通讯！\n\n### 5.ICMP协议\n\nICMP作为IP协议栈的一部分且报文封存在IP分组中，每一个系统均要实现ICMP，可能在传输过程中经过很多个物理子网才可以到达最终目的地，ICMP报文通常用于检测网络是否存在故障，PING一台主机就是发送ICMP报文。\n\n### 6.场景化分析\n\n以太网的数据帧包含有**自己MAC地址**和**目标MAC地址**，局域网（子网）内，通过ARP协议广播获取到所在局域网的电脑的MAC地址，假如a电脑`172.13.4.58`需要发消息给b电脑`172.13.4.90`，首先需要判断目的IP是否属于同一子网，直接广播发送数据报文，报文情况如下：\n\n```text\n自己MAC：1a:2f:6c:ee:39:5d\n目标MAC：ff:ff:ff:ff:ff:ff  // 未知对方MAC\n自己IP：172.13.4.58\n目标IP：172.13.4.90\n```\n\n子网内交换机ARP报文获取得到目的IP对应的MAC地址，随之将消息发送给目的电脑，目标电脑响应一个报文，其中带有自己的MAC地址返回给a电脑，这时a电脑下次发送报文则带有b电脑的MAC地址。如果a，b电脑不在同一个网络则a电脑的报文发送给网关，网关交给路由器，转发到b电脑对应的子网。\n\n\n\n\n\n## 传输层\n\n前三层已经基本实现计算机通讯，但是我们计算机通常开启很多程序，例如QQ，微信，LOL程序，软件都需要进行网络传输，我们无法进行区分数据是具体送达哪一个程序，这时引入传输层，传输层定义端口的概念，每一个程序占用一个端口。传输层有两大协议TCP和UDP，根据IP实现数据传输，通过端口确定发送给某个进程。\n\n![leFHzgC7wmoGRUB](https://s2.loli.net/2022/05/19/leFHzgC7wmoGRUB.png)\n\n### TCP协议\n\n面向连接的可靠传输，提供全双工信道，面向字节流，TCP数据报文没有长度限制，但是为了保证网络效率，通常TCP报文不会太长，TCP报文头部主要是源端口和目标端口，TCP协议将客户端和服务端的socket套接字连接，连接过程需要进行三次握手，进行传输数据，断开连接需要进行四次挥手！\n\n![qz39GxSmn4VW2Fe](https://s2.loli.net/2022/05/19/qz39GxSmn4VW2Fe.png)\n\n#### <u>三次握手</u>\n\n![dSreu8gqMCxWLt3](https://s2.loli.net/2022/05/19/dSreu8gqMCxWLt3.png)\n\n![5phEPSe62RZ3LJX](https://s2.loli.net/2022/05/19/5phEPSe62RZ3LJX.png)\n\n#### <u>四次挥手</u>\n\n![PKZMAaCz8cUg5h9](https://s2.loli.net/2022/05/19/PKZMAaCz8cUg5h9.png)\n\n\n\n### UDP协议\n\n无连接的不可靠传输，报文头部一共只有8个字节，总长度不超过65535字节，不会出现重传的现象，传输只管发送，不在乎目的地址是否收到。\n\n![CfNB2gX7axEPA4D](https://s2.loli.net/2022/05/19/CfNB2gX7axEPA4D.png)\n\n\n\n\n\n## 应用层\n\n用户软件均工作与应用层，应用层规定数据的格式，TCP协议可以传递多种格式数据，HTTP协议规定网页数据格式，FTP协议规定文件传输格式，多种应用协议构成应用层，连接应用层和传输层的技术API叫套接字socket，应用通过调用socket接口实现对网络层和传输层的数据封装，为应用进程之间建立通信连接。\n\n![msF7Q4ERng9HUST](https://s2.loli.net/2022/05/19/msF7Q4ERng9HUST.png)\n\n\n\n\n\n## 总结\n\n数据传输就是`发送方封装数据报文`和`接收方拆开数据报文`的过程\n\n![DdZVQ7WE3POxAam](https://s2.loli.net/2022/05/19/DdZVQ7WE3POxAam.png)\n\n![hSmsz5Y3MBrnWUP](https://s2.loli.net/2022/05/19/hSmsz5Y3MBrnWUP.jpg)\n\n\n\n\n\n## 场景化分析\n\n我们在谷歌浏览器地址栏输入huasenjio.top域名时回车时，浏览器向服务器请求资源到展示页面，大体上分为如下几个步骤：\n\n1. 浏览器判断/校验/补齐，判断用户输入地址是否合法规范，补齐未输入的http协议，参数编码等操作；\n2. 通过DNS解析IP地址，浏览器优先查询缓存中是否存在huasenjio对应的IP地址，存在则将IP赋值给请求头中Remote Address参数，假设不存在，则查询HOST文件是否预设huasenjio.top对应的IP地址，如果仍未找到则请求电脑设置的DNS服务器，国外较为出名谷歌DNS服务器`8.8.8.8`，国内比较出名南京国风`114.114.114.114`，浏览器发起网络请求，首先在应用层对报文进行封装DNS协议信息，其次传输层UDP协议对报文进行封装相关信息，网络层IP协议封装相关信息，根据子网掩码和IP进行`与运算`发现不等于网关则说明不属于一个子网，直接发送至a网关路由器，数据链路层中路由器根据ARP协议进行地址解析，广播报文，收到播回应，形成路由表（IP对应MAC地址），进行将报文封装成为MAC帧，根据CSMA/CD报文对应转化为物理层的曼切斯特编码，比特流通过传输介质传输到下一个路由器处理，如此重复，最后进入`8.8.8.8`所在的子网的b网关路由器中，b网关路由器获取到报文，通过ARP协议根据IP获取到对应的MAC地址，之后进入对应网卡中，再进行逆序解析，由物理层网上至应用层一点一点拆开封装分数据，最后请求到对应的程序，获取得到huasenjio所对应的IP地址；\n3. 浏览器获取到huasenjio对应的47.98.129.109（IP地址），首先将IP赋值给HTTP请求头中Remote Address参数，进入传输层TCP报文封装信息，进而进入网络层封装IP协议信息，根据子网掩码和47.98.129.109进行`与运算`发现不等于网关则说明不属于一个子网，直接发送至a网关路由器，进入数据链路层中路由器根据ARP协议进行地址解析，广播报文，收到单播回应，形成路由表（IP对应MAC地址），进行将报文封装成为MAC帧，根据CSMA/CD报文对应转化为物理层的曼切斯特编码，比特流通过传输介质传输到下一个路由器处理，如此重复，进入到47.98.129.109对应子网的c网关路由器，通过ARP协议根据IP获取到对应的MAC地址，之后进入对应网卡中，再进行逆序解析，由物理层网上至应用层一点一点拆开封装分数据。往返进行相互发送报文，俗称三次握手，建立TCP连接，开始传输数据；\n4. 浏览器解析HTMLl源码标签，根据标签嵌套创建DOM树，并行加载静态资源文件，每一个HTML标签都是文档树中的一个节点，构成了由documentElement节点为根节点的DOM树；\n5. 浏览器解析CSS代码，计算得出样式数据，非法的语法被直接忽略掉，解析CSS时按照优先级`浏览器默认设置 < 用户设置 < 外链样式 < 内联样式 < !important`的规则解析，构建CSSOM树；\n6. js引擎进行注册事件操作，并将DOM和CSSOM树合成渲染树，最后通过渲染引擎渲染；\n7. 如果渲染树中的节点被移除、位置改变、元素的显示隐藏等属性改变都会重新执行上面的流程，这一个行为称为回流；与重绘不同，重绘是渲染树上的某一个属性需要更新且仅影响外观、风格，不影响布局，例如：修改background-color就属于重绘只是重新绘制到屏幕中上，回流必定造成重绘；",
      "isDraft": "false",
      "publisher": "932397243@qq.com",
      "tag": "基础/理解/网络协议",
      "time": "2022-5-19",
      "title": "计算机网络通讯的理解"
    },
    {
      "bannerImg": "huasen-public-static/admin/1650137859777.png",
      "code": "0",
      "content": "# 概念名词\n\n| 名词     | 说明                                   |\n| -------- | -------------------------------------- |\n| 数据     | 信息的载体且能被计算机所处理的符号集合 |\n| 数据元素 | 数据的基本单位                         |\n| 数据项   | 构成数据元素的基本单位                 |\n| 数据对象 | 性质相同的数据元素集合                 |\n\n场景化分析，将数据定义为学生数据，数据对象就是学生信息表，数据元素就是学生信息表中的一名学生，数据项就是学生的名字信息。\n\n# 数据结构\n\n数据在计算机中的组织方式，数据结构指相互之间存在一种或多种特定关系的数据元素的集合，较优的数据结构可以带来更高的运行和储存效率，数据之间的关系分为逻辑关系和物理关系（存储结构），逻辑结构是数据结构的抽象，物理结构是数据结构的实现。\n\n### 1.逻辑结构\n\n1. 集合结构，元素之间除了同属于一个集合外无任何其他关系；\n2. 线性结构，结构中的数据元素之间存在一对一的线性关系；\n3. 树型结构，结构中的元素之间存在一对多的层次关系；\n4. 图状结构和网状结构，结构中元素存在多对多的任意关系；\n\n![](https://gitee.com/HuaSenJioJio/huasen-markdown-article/raw/master/数据结构与算法描述/img/eypxXd2020111027.png/)\n\n### 2.存储结构\n\n1. 顺序结构，储存在一块地址连续的存储单位，常用于数组进行实现顺序存储；\n2. 链表结构，一组任意的存储单元进行存储数据，数据之间的逻辑关系通过指针进行表示，存储节点存在一个指针指向下一个节点地址，最后一个节点的指向 null；\n3. 索引结构，储存节点信息的同时，另外建立索引表，索引表中的每一项成为一个索引项；\n4. 散列结构，通过节点的关键词，根据公式计算出节点所在的内存地址；\n\n### 3.概念小结\n\n![](https://gitee.com/HuaSenJioJio/huasen-markdown-article/raw/master/数据结构与算法描述/img/EWhEuI2020111032.png/)\n\n# 算法设计分析\n\n### 1.要求\n\n1. 正确性；\n2. 可读性；\n3. 健壮性；\n4. 高效性；\n\n### 2.算法特性\n\n1. 有穷性，必须总是在优先步骤之后完成；\n2. 确定性，算法中每一条指令必须有确切的含义；\n3. 可行性，算法是可执行；\n4. 输入，一个算法有 0 个或者多个输入；\n5. 输出，一个算法必须有一个或者多个输出；\n\n### 3.空间复杂度\n\n程序算法在执行时所占用的内存，空间复杂度过高的算法可能会超出限制内存，导致程序异常终止。算法本身需要占据一些空间，而且算法需要使用辅助空间完成任务。\n\n### 4.时间复杂度\n\n程序算法在执行时所消耗的时间，时间复杂度过高的算法可能让有生之年都看不到运行结果，通常平均时间复杂度比较难以求解，所以一般仅考虑最坏时间复杂度。\n\n### 5.分析小窍门\n\n计算机做加减法的速度远快于乘除法，所以评判复杂度一般会看乘除法而忽略加减法，假设现在拥有两个时间复杂度 T1，T2，对应两个函数 f1，f2，则有一下结论：\n\n1. T1+T2 的复杂度取决于两者中的较大值；\n2. T1\\*T2 的复杂度取决于相乘；\n3. T（n）是关于 n 的 k 阶多项式，那么复杂度取决于 n 的 k 次方，忽略低次幂和最高次幂项数；\n4. for 循环的时间复杂度是循环的次数和代码体中的代码复杂度；\n5. if-else 结构复杂度取决于 if 判断的条件和两个分支的复杂度，总体复杂度取决于三者中的最大值；\n\n# 线性表\n\n### 1.线性表的定义和特点\n\n线性表是相同性质的数据元素的有限序列，除了起点和终点，每一个元素都存在一个直接前驱和直接后驱，数据元素的个数 n 称为表长，存储空间分配不灵活，运算的空间复杂度相对较高。\n\n![](https://gitee.com/HuaSenJioJio/huasen-markdown-article/raw/master/数据结构与算法描述/img/cczzMv2020111035.png/)\n\n### 2.线性线性表\n\n逻辑上相邻的数据元素在物理介质上也是相邻的存储单元，内存中占用一块连续的地址空间，知道一个元素所在单元和单元大小，就可以推算出所有元素所在的存储单元，`Loc（ai）= Loc（a1）- (i-1)L`，其中 L 为一个元素所占单元长度。\n\n#### <u>查找操作</u>\n\n假设一个有 n 个数据元素的数组，有幸第一次匹配上则执行匹配判断一次，不幸最后判断匹配或者未查找到则匹配 n 次，如果匹配的元素在第 3 个位置则需要判断 3 次，如果匹配元素在第 7 个位置则需要判断 7 次，所以得出以下公式`1*1/n + 2*1/n + ... n*1/n`，经过简化得到，`1/n*(1+2+3+...n)`，最后得出`(n+1)/2`的时间复杂度，所以匹配查找的时间复杂度是 O=n，可以通过哨兵模式减少时间复杂度。\n\n#### <u>插入操作</u>\n\n插入时需要考虑插入的位置（1~n+1），存在几个情况插入方法，头插法，尾插法，中间插法，同样要对非法异常的插入位置进行提醒。如果尾插法速度最快；如果中间插法则需要将插入位置空出再进行插入；如果是头插法则需要后移全部元素。\n\n![](https://gitee.com/HuaSenJioJio/huasen-markdown-article/raw/master/数据结构与算法描述/img/A5UOiN2020111043.png/)\n\n插入位置为 1 时需要移动 n 次，插入位置为 n+1 时需要移动 0 次，插入位置为 n 时需要移动 1 次，不难发现，插入位置和移动次数之和等于 n+1，因为每个位置插入的概率 1/n+1，所以得出以下公式并求出时间复杂度 O（n），n 趋于无穷大则可以忽略掉常数分母。\n\n![](https://gitee.com/HuaSenJioJio/huasen-markdown-article/raw/master/数据结构与算法描述/img/GMxuc82020111038.png/)\n\n#### <u>删除操作</u>\n\n传入一个 i，对第 i 个节点删除，i（1~n）的位置必须是合法参数，如果头删法则需要将后面所有元素向左移动一个位置覆盖掉删除的位置元素；如果是尾删法则直接长度减一，如果是中心删除则需要将后面元素左移覆盖掉删除位置的元素。\n\n![](/Users/huasenjio/Library/Application Support/typora-user-images/image-20201110203603172.png//)\n\n删除位置为 1 时需要移动 n-1 次，删除位置为 2 时需要移动 n-2 次，删除位置为 n 时需要移动 n-n 次，不难发现，移动次数等于元素个数和删除位置之差，因为每一个元素都有 1/n 被删除的概率，所以得出以下公式，得出时间复杂度 O(n)，当 n 趋于无穷大时，常数项可以忽略。\n\n![](https://gitee.com/HuaSenJioJio/huasen-markdown-article/raw/master/数据结构与算法描述/img/qhIdT82020111034.png/)\n\n#### <u>总结</u>\n\n1. 优点，存储密度大（节点本身存储量/节点结所存储量=1），可以取得表中的任意元素；\n2. 缺点，删除元素时耗时过大，浪费存储空间，属于静态存储形式不可以自由扩充\n\n### 3.链式线性表\n\n节点在存储介质中是可以在任意位置，逻辑上相邻的数据元素物理上不相邻，节点包括数据项和地址项，数据项指数据元素信息，地址项指向下一个节点的地址（最后节点指向 null）。 单链表由头指针唯一确定，所以单链表可以使用头指针进行命名。\n\n![](https://gitee.com/HuaSenJioJio/huasen-markdown-article/raw/master/数据结构与算法描述/img/Bksv3A2020111012.png/)\n\n#### <u>链式线性表分类</u>\n\n1. 单链表，节点组成`数据域 指针域`，指针域指向后一个节点的位置；\n2. 双链表，节点组成`指针域1 数据域 指针域2`，指针域 1 指向前一个节点的地址，指针域 2 指向后一个节点地址；\n3. 循环链表，头尾相连的链表；\n\n![](https://gitee.com/HuaSenJioJio/huasen-markdown-article/raw/master/数据结构与算法描述/img/foKluO2020111145.png/)\n\n#### <u>链式线性表概念</u>\n\n头指针/头结点/首元结点\n\n![](https://gitee.com/HuaSenJioJio/huasen-markdown-article/raw/master/数据结构与算法描述/img/wVJEir2020111151.png/)\n\n#### <u>表现定义</u>\n\n单链表存储结构和数据表示\n\n![](https://gitee.com/HuaSenJioJio/huasen-markdown-article/raw/master/数据结构与算法描述/img/P8ExPr2020111113.png/)\n\n#### <u>初始化单链表</u>\n\n生成一个存在指针域和数据域的头结点，将头结点的指针域赋值为 null 值，同样判断也是可以通过头指针判断是否单链表为空。\n\n#### <u>单链表销毁</u>\n\n借助一个指针 p 指向第一个元素，L 头指针向后一个位置，`L=L->next`，再删除 p 指针所指向的节点，利用 while 循环一次进行，直到 L 指向 null 则循环结束。\n\n![](https://gitee.com/HuaSenJioJio/huasen-markdown-article/raw/master/数据结构与算法描述/img/odU5Wx2020111102.png/)\n\n#### <u>清空单链表</u>\n\n依次释放所有节点，仅保留头结点和头指针，并且将头指针的指针域赋值成为 null 值。\n\n![](https://gitee.com/HuaSenJioJio/huasen-markdown-article/raw/master/数据结构与算法描述/img/ab1W9y2020111140.png/)\n\n![](https://gitee.com/HuaSenJioJio/huasen-markdown-article/raw/master/数据结构与算法描述/img/RT809U2020111134.png/)\n\n#### <u>单链表表长</u>\n\n设置指针 p 指向首元节点，从首元节点开始，指针 p 后移`p=p->next`，使用一个变量进行计数，直到 p 的值为 null，最后输出表长。\n\n```c\np = L-> next; // p指向首元节点\ncount = 0;  // 计数器\nwhile(p) {\n  count++;\n  p = p-> next；// 将p指向下一个节点\n}\nreturn count； // 返回表长\n```\n\n#### <u>取值</u>\n\n一个带头节点的单链表 ，建立 p 指针首元结点开始，往下遍历且设置计数器，当计数值等于索取元素的序号时，输出 p 对应的 data 域。如果当为 null 且计数器未和索取需要匹配则说明不存在该序号元素，进行报错反馈。\n\n![](https://gitee.com/HuaSenJioJio/huasen-markdown-article/raw/master/数据结构与算法描述/img/GMjrvQ2020111158.png/)\n\n#### <u>按值查找</u>\n\n一个带头结点的单链表， 建立指针 p 指向首元节点，往下遍历的同时判断节点的 data 域与给定词匹配，匹配则输出，如果 p 为 null 仍然未匹配则说明未找到。\n\n![](https://gitee.com/HuaSenJioJio/huasen-markdown-article/raw/master/数据结构与算法描述/img/Q8Z8ZN2020111154.png/)\n\n#### <u>插入</u>\n\n一个带头结点的单链表，建立 p 指向插入位置的前一个节点，建立一个 s 指针指向新节点，将新节点的指针域指向原先该位置的节点，`s->next = p->next`，p 所指节点的指针域指向新元素，`p->next = s `，完成按给定位置插入新元素。\n\n![](https://gitee.com/HuaSenJioJio/huasen-markdown-article/raw/master/数据结构与算法描述/img/m3QZDO2020111138.png/)\n",
      "isDraft": "true",
      "publisher": "932397243@qq.com",
      "tag": "算法/数据结构/C++/未完结",
      "time": "2022-5-6",
      "title": "数据结构和算法描述"
    },
    {
      "bannerImg": "huasen-public-static/admin/1650137867777.png",
      "code": "0",
      "content": "# 操作系统\n\n### 1.概念\n\n操作系统(Operation System OS) 管理和控制计算机硬件与软件资源的计算机程序，直接运行在物理设备上的系统软件，任何其他的引用程序均是在操作系统平台上运行，操作系统是计算机资源的管理者，主要协调如下几个方面：\n\n1. 处理机管理；\n2. 存储器管理；\n3. 设备管理；\n4. 文件管理；\n\n同时操作系统也是用户和硬件设备交互的工具，用户可以通过系统开放的API接口进行与硬件接口交互，具有如下几个场景：\n\n1. 命令行接口，调用CMD命令行查询当前网卡的MAC地址；\n2. 程序接口，程序内调用print接口实现显示输出内容在屏幕；\n\n### 2.功能\n\n1. 操作系统管理硬件和软件及数据资源；\n2. 控制应用程序运行；\n3. 增加用户使用体验（可视化界面）；\n4. 作为其他应用软件的平台；\n\n### 3.特征\n\n1. 并发，两个或者多个任务在同一个时间间隔内发生；\n2. 共享，系统中的资源可供内存中多个并发执行的进程共同使用；\n3. 虚拟，物理设备变为若干个逻辑对应物；\n4. 异步，躲到程序环境下，允许多个程序并发执行，程序不是同步执行而是延后执行是进程异步性的体现；\n\n\n\n\n\n# 基本概念\n\n1. 互斥，进程之间访问临界资源时相互排次的现象；\n2. 临界资源，一次仅允许一个进程使用，例如：打印机，IO输入输出设备；\n3. 临界区，包含临界资源的代码段；\n4. 并发，同一个时间段，多个进程同时从启动到运行完毕，并发的两种关系是同步和互斥；\n5. 并行，单核处理器中，进程之间不允许同时执行，多个经常交替执行也有可能重叠执行，进程不需要同一个时刻发生；\n6. 同步，进程之间存在依赖关系，一个进程结束结果是另一个进程的输入；\n7. 异步，进程之间彼此独立，开启运行时刻不确定不统一，不需要等待其他进程完成或者开始；\n8. 多线程，进程并发执行一段代码，实现进程之间切换执行，异步不同等于多线程，多线程是实现异步的一个手段；\n\n\n\n\n\n# 发展历程\n\n- 手工阶段\n- 单道批处理系统\n- 多道批处理系统\n- 分时操作系统\n- 实时操作系统\n- 网络操作系统和分布式操作系统\n\n网络操作系统和分布式操作系统的不同，分布式操作系统中多太计算机相互协作完成同一个任务，网络操作系统中每台计算机都是相互独立。\n\n\n\n\n\n# CPU工作状态\n\n大多数计算机系统将CPU的执行状态分为目态和管态，管态又称特权态，CPU管态状态下可以执行系统的全部指令；目态称为用户态，目态状态下程序仅能执行非特权指令，不能直接使用系统资源，不可以改变CPU的工作状态并且仅能访问属于自己的存储空间。如下几个方法可以将目态转化成为管态：\n\n1. 系统调用，用户态进程通过系统调用申请使用操作系统习惯的服务程序完成工作；\n2. 异常，CPU执行用户态程序发送位置异常，此时触发处理异常处理的内核程序，完成目态到管态的切换，例如缺页异常；\n3. I/O设备中断，用户态申请IO设备操作并完成后，CPU发出相应的中断信号，此时CPU暂停用户程序代码，将优先执行中断信号对应的处理程序；\n\n\n\n\n\n# 处理机管理\n\n### 1.进程控制\n\n传统多道程序环境中，一个作业任务运行，必须创建一个或者多个进程并为之分配必要的资源，进程结束后立即销毁进程，及时收回进程占用的各类资源；\n\n### 2.进程同步\n\n通过多个进程协调运行\n\n### 3.进程关系\n\n##### <u>互斥关系</u>\n\n进程（线程）在对临界资源进行访问则属于互斥关系\n\n##### <u>同步关系</u>\n\n相互协作合作完成共同任务的进程，一个进程结束结果是另一个进程的输入。\n\n### 4.进程通讯\n\n多道程序环境下为了加速应用进程的运行时间，系统中建立多个进程并且为一个进程建立若干个线程，进程（线程）相互合作完成一个共同的任务，进程线程中需要交互通讯。\n\n### 5.调度\n\n后备队列中等待的作业或者进程，经过CPU调度后才可以执行。\n\n\n\n\n\n# 存储器管理\n\n### 1.内存分配\n\n采用静态和动态两种方式实现内存分配，记录内存使用情况，按照一定的算法进行对不在被需要的内存进行收回合并。\n\n### 2.内存保护\n\n确保用户程序仅在自己内存空间运行彼此相互独立\n\n### 3.地址映射\n\n编译后的程序地址分为逻辑地址和物理地址，每个程序不可能均能占据连续的物理内存，所以必须采用地址映射的方式将逻辑地址转换成内存空间的物理地址。\n\n### 4.动态重定位\n\n需要访问的程序数据的逻辑地址动态转换成实际的物理地址，通过重定位寄存器，记录安装程序时所在内存中的首地址，程序执行时通过将相对地址和重定位寄存器中的地址计算，实现动态重定位。\n\n### 5.内存扩充\n\n逻辑上扩充内存容量，实现原理是划取实际内存中的一部分内存，作为映射表，将本需要存在内存中的数据通过映射表存入实际硬盘中，通过映射表中的相对地址去寻找实际的物理地址。\n\n\n\n\n\n# 设备管理\n\n### 1.缓冲管理\n\nCPU速度非常快，但是IO读写相对缓慢，所以引入缓冲区机制能够有效缓解CPU高速性和IO低速性之间的矛盾。\n\n### 2.设备管理\n\n设置设备控制表，控制器控制表等数据结构，目的获取指定设备当前状态，是否可用，忙绿，进而解决协调进程之间调用冲突。\n\n### 3.设备处理程序\n\n处理CPU和设备管理器之间的通信，通过CPU向设备控制器发送IO命令，设备控制器调用IO设备进行指定的读写操作。\n\n\n\n\n\n# 文件管理\n\n### 1.文件存储空间管理\n\n文件系统对资源的存储空间实施统一的管理，每个资源文件分配必要的外存空间，提高外存的利用率和文件系统的执行速度。\n\n### 2.目录管理\n\n文件资源的索引，建立目录以及文件对应的路径关系，方便用户查阅资源文件。\n\n### 3.文件读写管理保护\n\n防止未经批准的用户存取文件，不正当行为修改使用文件的行为。\n\n\n\n\n\n# 进程与线程\n\n对于操作系统而言，一个任务就是一个进程（process），打开电脑记事本就是启动一个记事本进程，进程中的子任务成为线程，事本中的拼写检查是进程启动后建立出来的线程，线程辅助进程运行。\n\n### 1.进程\n\n进程是程序执行的一个实例，进程是操作系统进行资源调度分配的单位，每一个进程拥有独立的地址空间，`进程=程序+数据+PCB`，其中PCB是**进程控制块**保存进程运行时的上下文，PCB是进程存在的唯一标志，进程之间无法直接访问，需要通过管道，文件，套接字等技术才可以实现通讯。\n\n### 2.进程状态\n\n进程的基本五种状态改变\n\n![iTlrjabNRpAnZQz](https://s2.loli.net/2022/05/19/iTlrjabNRpAnZQz.png)\n\n1. 创建状态，进程正在被创建，尚未转到就绪状态，创建过程中需要申请一个空白的PCB并写入一个控制和管理进程的信息，等待系统分配资源，进程进入就绪状态；\n2. 就绪状态，进程准备执行的状态，已经获取CPU之外的所有资源，处于进程队列中准备被CPU调度；\n3. 执行状态，进程正在被CPU调度执行，如果是单处理机环境下，同一个时刻仅可以执行同一个进程；\n4. 阻塞状态，进程中由于调用IO操作导致等待某一个事件而暂停运行，此时进入阻塞状态，IO操作完成后进入就绪状态队列等待被CPU调度；\n5. 结束状态，进程开始被销毁消失，正常执行完成和异常中断均可以导致进程被销毁，进程准备销毁时必须处于结束状态，随后操作系统进行处理资源释放和回收等操作；\n\n值得注意的是后备队里存在于外存中，而就绪状态的进程存在于内存中，方便高效地被调度。\n\n### 3.进程同步与互斥\n\nPV操作是实现PV操作是一种实现，PV操作与信号量的处理相关，P代表通过，V代表释放，PV操作操作信号量S，信号量S大于或者等于零，表示可以被进行调用的资源实体数，信号量S小于零时，表示正在等待资源的进程数，所以信号量S是代表资源数。\n\n##### <u>P操作</u>\n\n```javascript\nS减1（占用一个资源数）\nif（S减1 >= 0）{\n\t// 程序继续执行\n}else {\n  // 该进程进入阻塞队列中等待被调度\n}\n```\n\n##### <u>V操作</u>\n\n```javascript\nS加1（释放一个资源数）\nif（S加1 > 0）{\n\t// 代表存在可以使用的资源，该进程继续执行。\n}else {\n  // 从阻塞等待队列中调用一个进程使用，再继续执行该进行。\n}\n```\n\n值得注意的是PV操作对于每一个进行而言仅能执行一次且必须成对使用\n\n### 4.进程通信\n\n根据交换信息量的多少和效率的高低，将进程通信分为低级通讯和高级通讯模式。\n\n#### <u>低级通信</u>\n\n仅能传递状态和整数（控制信息），具有传输信息量小，效率低，容量固定的特点，实现通讯难度较大。\n\n#### <u>高级通信</u>\n\n提高信号通信的效率，传递大量数据并减轻编程的复杂度，高级通信分为如下三种方式：\n\n1. 共享内存模式，通信进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作，实现进程之间的信息交换。进程对共享空间进行写/读操作时，需要同步互斥工具（ PV操作）；\n\n![7n45ZyHWJhiblvr](https://s2.loli.net/2022/05/19/7n45ZyHWJhiblvr.png)\n\n2. 消息传递模式，消息传递模式中，进程间的数据交换是以格式化的消息(Message)为单位，进程通过系统提供的**发送消息**和**接收消息**两个原语进行数据交换，可以分为直接和间接通信方式；\n\n```javascript\n类比：\n甲给乙写信\n直接：甲直接把信交给乙\n间接：甲通过邮差把信交给乙\n```\n\n3. 共享文件模式，共享缓冲区（pipe管道）连接一个发送进程和一个接收进程，进程向管道内输入发送信息，信息以字节流的形式通过管道传入其他进程没实现进程通信；\n\n![Zwb1fe2DmOyWQzM](https://s2.loli.net/2022/05/19/Zwb1fe2DmOyWQzM.png)\n\n### 5.线程\n\nCPU的执行单元，执行流的最小单元，由线程ID，程序计数器，寄存器和堆栈组成，线程是CPU调度的基本单元。线程拥有**线程控制块TCB**保存运行期间线程的数据，TCB是线程存在的唯一标志，线程有以下几个场景解释：\n\n1. 线程属于进程中的一个实体，线程是CPU独立分配的基本单位；\n2. 线程不拥有系统资源，但是可以共享进程中所拥有的其他资源；\n3. 进程可以创建和撤销一个线程，同一个进程之间可以存在多个进程并发；\n\n### 6.总结\n\n- 进程是资源分配和调度的一个独立单元，线程是CPU调度的基本单元；\n- 一个进程中可以包括多个线程，并且线程共享整个进程的资源，一个进程至少包括一个线程；\n- 进程的创建调用fork或者vfork，但是线程的创建调用pthread_create，进程结束将拥有线程都销毁，线程的结束不会影响进程其他线程；\n- 线程是轻量级的进程，线程创建和销毁所需要的时间比进程小很多；\n- 线程中执行都要进行同步和互斥，线程共享同一进程的所有资源；\n- 线程和线程之间的资源不会被共享；\n\n\n\n\n\n# CPU调度\n\n处理机调度线程有三种方法：\n\n1. 高级调度（作业调度），调度处于外存后备队列的进程进入内存执行；\n2. 中级调度（内存调度），展示不能运行的进程移入外存后备队列等待，进程状态改为就绪且驻外状态或者挂机状态；\n3. 低级调度（进程调度），根据调度算法将内存中的就绪队列中的进程进行处理；\n\n### 1.调度算法\n\n调度算法是系统根据资源分配策略的规则，有的算法用于作业调度，有的适用于进程调度，同样有的算法都将适用。调度算法的考量`周转时间=等待时间+执行时间`，通过周转时间取决于适用算法。\n\n#### <u>先来先服务(FCFS)</u>\n\n先来先服务调度(First Come First Service)，按照作业/进程进入系统的先后次序进行调度，先进入系统者先调度，适用于作业调度，进程调度，算法简单，对长进程有利，短进程吃亏（骂骂咧咧：我这么短也要等这么久！），不利于IO频繁的进程。\n\n#### <u>短作业优先调度(SJF)</u>\n\n短作业优先调度(Shortest Job First)，算法每次从队列中挑选估计执行时间最短的进程交给CPU处理。适用于作业调度和进程调度，具有平均等待时间和平均周转时间最少的优点，对于长作业不利（骂骂咧咧：什么时候可以轮到我！）不能保证紧迫性作业/进程会被及时处理。\n\n#### <u>优先级调度</u>\n\n优先级调度，算法每次从后备队列/就绪队列中选择优先级最高的一个作业/进程，根据新的更高优先级进程能否抢占正在执行的进程，可以将调度分为：\n\n1. 非抢占式优先级调度算法，当队列中进入优先级更高的进程时，不会中断正在执行的进程，而是等待CPU空闲后再调度优先级较高的进程；\n2. 抢占式优先权调度算法，当队列中进入优先级更高的进程时，中断正在执行的进程，抢夺CPU资源；\n\n#### <u>高响应比优先调度(HRRN)</u>\n\n高响应比优先调度(Highest Response Ratio Next)，算法是对FCFS调度算法和SJF调度算法的一种综合平衡，CPU对队列中每个进程计算响应比，响应比高的作业优先执行`响应比=作业周转时间/作业执行时间=(等待时间+要求服务时间)/要求服务时间`，但是调度前要进行计算响应比，增加系统开销。\n\n#### <u>时间片轮转调度</u>\n\n算法将所有就绪进程按到达的先后次序排成一个队列，CPU按队列顺序传递时间片，进程享有同样的调度时间，时间片用完则计时器发出中断请求。\n\n#### <u>多级反馈队列调度</u>\n\n将进程分入不同的就绪队列并设置队列调度优先级，通过不同的队列优先级设置不同的时间片，同一队列中采用先来先服务的调度策略，多级反馈队列中后来的进程不一定最后完成！\n\n\n\n\n\n# 死锁\n\n多个进程竞争临界资源而造成相互等待的僵局，如果没有外部调节，进程无法继续执行，产生死锁的本质是系统提供的资源个数小于进程需求个数，资源使用造成环路必定造成死锁。\n\n```javascript\nA同学有纸\nB同学有笔\n\n需要完成写字操作\n\nA同学说：“你不给我笔，我就不能写字！”\nB同学说：“你不给我纸，我就不能写字！”\n\n相互不肯让出造成僵局\n```\n\n产生死锁的必要条件：\n\n1. 互斥条件，涉及的资源是非共享，一次仅能被一个进程使用；\n2. 不剥夺条件，进程不会剥夺其他进程正在使用的非共享资源；\n3. 占有等待，进程等待其他资源同时，同时占据已分配的资源；\n4. 环路条件，存在一种进程循环链，链中每一个进程已获得的资源同时被链中下一个资源所请求；\n\n### 1.预防死锁\n\n设置进程的限制条件，破坏死锁的一些必要条件，使其不能产生死锁。\n\n### 2.避免死锁\n\n动态分配资源的过程，使用银行家算法防止系统进入不安全状态，避免死锁的发生。新进程进入系统，必须说明各类型资源的的最大需求量，数量不能超过系统各个类的资源总数，如果有一个类型系统不能够提供则进程进行等待状态，简而言之，进程申请者可以在一定时间内无条件归还它申请的全部资源，系统才会把资源分配它。\n\n### 3.死锁的检测和解除\n\n如果发生死锁，可以采取资源剥夺法，撤销法，进程回退法进行解除死锁。\n\n\n\n\n\n# 主存管理\n\n### 1.分区存储管理\n\n分区存储管理中程序的地址空间时一堆线性的连续地址，分区管理即对存储介质的地址进行分区块进行存储文件资源，分区储存管理中的分配策略有：\n\n1. 首次适应法，程序按地址从小到大排序，分配给第一个符合条件的分区，具有保留高地址部分的大空闲区，有利于大型程序作业分配，但是低地址不断被划分，留下许多难以利用的碎片；\n2. 循环首次适应法，从上次查找结束为止开始查找第一个合适的分区进行存储，具有空闲空间分区相对均匀和减少查找时间的优点，但是可能导致缺乏大空间区域；\n3. 最佳适应算法，空间从小到大排序进程查找，分配第一个符合条件的分区，具有每次分配都是最合适的空间，但是可能导致难以利用的小空闲区域；\n4. 最坏适应算法，地址从大到小排序，匹配第一个符合条件的分区；\n\n### 2.页式存储管理\n\n页式存储管理只用给出一个逻辑地址，页面大小固定，`逻辑地址÷页的大小=页号`且余数等于偏移量，所以地址空间用一个逻辑地址表示，地址映射过程中，若发现所要访问的页面不在内存则产生缺页中断，发送中断时操作系统内存没有空闲空间，通过算法决定淘汰页面，`缺页中断率=成功访问次数/总访问次数`，抖动（颠簸）指页面置换过程中，刚进入页面马上要被淘汰，刚淘汰跳出的页面又进行调入。页时存储管理的调度算法有以下几种：\n\n1. 最佳置换算法，最长时间内不会被访问的页面调出；\n2. 先进先出置换算法，最早进入内存的页面调出；\n3. 最近最久未使用算法等算法，最近最长时间未访问的页面调出，算法为每个页面设置一个访问字段，记录页面距离上次被访问经历的时间，调出页面时选择时间最长的页面；\n4. 最不经常使用置换算法，最近应用次数最少的页淘汰；\n5. 时钟置换算法(CLOCK)，算法是为每个页面设置一个使用位（1），页面被调用时使用为设置为0，其他页面调用使用位自加，需要页面替换时，淘汰使用位最高的页面；\n\n### 3.段式存储管理\n\n段式存储管理的用户地址是二维的按段进行划分，段式存储管理必须表明（段号和段内偏移量）。\n\n### 4.段页式存储管理\n\n段式存储管理结构中分别划分成为大小相等的页，段页式存储管理也必须给出（段号和偏移量），虽然段大小不固定，但是段内页号和页内偏移可以根据偏移量算出来。\n\n### 5.虚拟存储器\n\n指具有请求调入功能和置换功能并能从逻辑上对内存容量加以扩充的一种存储器系统，实现原理是**局部性原理**CPU访问存储器，无论存取指令还是存取数据，访问的存储单元都趋于聚集在一个较小的连续区域中，表现形式为如下两大特性：\n\n1. 时间局部性，一个数据被访问，近期很有可能再次被访问；\n2. 空间局限性，正在访问一个数据的地址，很有可能与将要访问数据的地址相邻；\n\n通过虚拟存储器技术，系统好像为用户提供一个比实际内存大得多的存储器，称为虚拟存储器，具有一下几个特征：\n\n1. 离散性，指内存分配时采用离散分配的方式；\n2. 多次性，进程运行时不是一次性加载全部页面，可分为多次载入；\n3. 对换性，作业运行时无序常驻内存，可以调入调出；\n4. 虚拟性，逻辑上扩充了内存的容量；\n\n\n\n\n\n# 文件系统\n\n文件分配对应于文件的物理结构规定为文件分配磁盘块，常用的磁盘空间分配方法有三种：\n\n1. 连续分配，文件在磁盘中占有一块连续的外存地址；\n2. 链接分配，采取离散分配的方式；\n3. 索引分配，每个文件盘块号集中在一起构成索引块（表）；\n\n### 1.磁盘调度算法\n\n#### <u>先来先服务算法</u>\n\n根据进程请求访问磁盘的先后顺序进行调度\n\n#### <u>最短寻找时间优先算法</u>\n\n选择调用请求文件所处磁道距离当前磁道所在位置最近进程\n\n#### <u>扫描算法(电梯算法SCAN)</u>\n\n磁头当前移动方向上选择与当前磁头所在距离最近的请求作为下一次服务的对象\n\n#### <u>循环扫描算法</u>\n\nSCAN算法的基础上规定磁头单向移动来提供服务，磁头到达磁盘端点返回时，直接快速返回起始端。\n\n\n\n\n\n# IO设备管理\n\n### 1.程序IO方式\n\n计算机从外部设备读取数据到存储器，每次读取一个字数据，CPU需要对外设状态进行循环检查，直到确定该字已经在I/O控制器的数据寄存器中。\n\n### 2.中断驱动I/O控制方式\n\n允许I/O设备主动打断CPU的运行并请求服务，从而使CPU在对I/O控制器发送命令后可以做其他工作，由于数据中每个字在存储器与I/O控制器之间的传输都必须经过CPU发送指令，消耗CPU较多的时间。\n\n### 3.DMA I/O控制方式\n\nI/O设备和内存之间开辟直接的数据交换通路，数据的基本单位是数据块，传送的数据是从设备直接送入内存。\n\n### 4.IO通道控制方法\n\n只在一组数据的传输开始和结束时需要CPU干预，可以实现CPU，通道，I/O设备三者的并行操作，适用于设备与主机进行数据交换是一组数据块的情况。\n\n### 5.缓冲区\n\n缓冲区(buffer)是内存空间的一部分，缓冲区存储空间用来缓冲输入或输出的数据，解除CPU和IO设备两者的制约关系，IO输入数据进入缓冲区时，CPU可以进行其他操作不必进行等待，引入缓冲区的目的有以下几点：\n\n- 缓和CPU与I/O设备间速度不匹配的矛盾；\n- 减少对CPU的中断频率，放宽对CPU中断响应时间的限制；\n- 解决基本数据单元大小（即 数据粒度）不匹配的问题；\n- 提高CPU和I/O设备之间的并行性；\n\n### 6.缓存（cache）和buffer的区别\n\nCPU的Cache即高速缓冲存储器，读写速度极快，几乎接近CPU，缓和内存和CPU之间速度不匹配的问题，buffer用于缓冲写入数据时CPU和IO设备速度不匹配。",
      "isDraft": "false",
      "publisher": "932397243@qq.com",
      "tag": "操作系统/原理/组成/未完结",
      "time": "2022-5-19",
      "title": "操作系统原理的理解"
    },
    {
      "bannerImg": "huasen-public-static/admin/1650168467282.png",
      "code": "2",
      "content": "# 日志分割步骤\n\n## 1.创建在根目录创建data文件夹  \nmkdir /data\n\n## 2.进入data文件  \ncd data\n\n## 3.创建runlog.sh脚本  \nvim runlog.sh\n\n## 4.脚本内容\n\n    #!/bin/bash\n    #建立日志对应的变量\n    LOGPATH=/usr/local/nginx/logs/access.log\n\n    #建立日志存放路径变量\n    BASEPATH=/data\n\n    #建立名时间的日志文件\n    bak=$BASEPATH/$(date -d yesterday +%Y%m%d%H%M).access.log\n    #生成\n    echo $bak\n    #将新日志移动到ginx的logs目录下\n    mv $LOGPATH $bak\n    #修改文件信息（不存在则生成）\n    touch $LOGPATH\n\n    #切割日志指令：\n    kill -USR1 `cat /usr/local/nginx/logs/nginx.pid`\n\n    #执行看看效果\n    sh runlog.sh执行一次\n\n    #进入日常任务管理：\n    crontab -e\n\n    #建立任务：（每天6点18分执行脚本）\n    */18 6 * * * sh /data/runlog.sh\n",
      "isDraft": "true",
      "publisher": "932397243@qq.com",
      "tag": "日志捕获/linux/nginx",
      "time": "2022-5-18",
      "title": "CentOS环境下切割Nginx日志任务"
    },
    {
      "bannerImg": "huasen-public-static/admin/1650137859777.png",
      "code": "0",
      "content": "# 策略模式在数据校验中的应用\n\n设计模式就是在**面向对象**软件设计过程中针对**特定问题**的简洁而优雅的解决方案，包含`发布者订阅者模式`、`策略模式`、`单例模式`等模式，分别作用于不同场景，本文便涉及到策略模式在数据校验中的应用。\n\n\n\n## 名词规约\n\n1. 策略模式：设计模式中的策略模式；\n2. 开放封闭原则：简称OCP，是所有面向对象原则的核心；\n3. 知识最少原则：迪米特法则，简称LOD，如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，其目的是降低类之间的耦合度，提高模块的相对独立性；\n\n\n\n## 介绍和理解\n\n关于策略模式，即定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。光从字面上理解，算是比较晦涩难懂，接下来我们将用小篇幅的例子介绍理解一下策略模式。\n\n### 问题场景\n\n假设某公司的年终奖金由个人工资基数+个人评级组成，关系如下所示：\n\n1. S级，个人工资基数*4；\n2. A级，个人工资基数*3；\n3. B级，个人工资基数*2；\n\n### 实现代码\n\n我们需要编写一段程序计算员工的年终奖金，于是有如下代码段：\n\n```javascript\n// 方法封装\nlet calculateBonus = function(level, salary) {\n  if ( level === 'S' ){\n   return salary * 4;\n  }\n  if ( level === 'A' ){\n   return salary * 3;\n  }\n  if ( level === 'B' ){\n   return salary * 2;\n  }\n}\n\n// 使用实例\ncalculateBonus(\"B\", 1000); // 2000\ncalculateBonus(\"S\", 1000); // 4000\n```\n\n我们不难发现代码逻辑很简单，但是缺陷也很明显，具体由如下几点：\n\n- 当条件过多时，出现较多if-else，并且要覆盖所有的逻辑分支；\n- 封装的方法缺乏弹性，若增加一个等级，则需要深入方法内部改动，违反开发封闭原则；\n- 复用性较差；\n\n### 重构代码\n\n尝试使用策略模式，重构本场景中的方法，本着定义一定的算法，一个个封装起来，把**不变**的部分和**变动**的部分隔离开的思想。基于策略模式的程序至少有**策略类**和**环境类**组成，环境类不参与业务逻辑，而是将请求委托给某个策略类完成。Javascript不同于其他传统的面向对象语言，所以实现更为简便，具体重构代码如下所示：\n\n```javascript\n// 策略组\nlet strategies = {\n  \"S\": function(salary) {\n    reture salary * 4;\n  },\n  \"A\": function(salary) {\n    reture salary * 3;\n  },\n  \"B\": function(salary) {\n    reture salary * 2;\n  }\n};\n\n// 环境组\nlet calculateBonus = function(level, salary) {\n  reture strategies[level](salary);\n}\n```\n\n由上面的例子，我们不难发现，环境组不直接执行业务相关，而是借助一定的算法，委托给策略类进行处理返回。如此一来可以轻易地将不变的部分抽离成库，方便复用拓展，如下图所示：\n\n![vUoMuctBL29XE7l](https://s2.loli.net/2022/05/31/vUoMuctBL29XE7l.png)\n\n\n\n## 表单校验中的运用\n\n在日常开发中，我们会遇到注册、登录、信息填写等功能，需要对大量的表单输入进行验证，而且重复性较大，所以我们照葫芦画瓢，尝试使用策略模式优化重构代码。\n\n### 核心代码\n\n环境类定义使用规则，通过算法转发校验请求，策略类处理环境类转发的**校验规则**和**数据**，属于动态变化的部分，属于团队间不断拓展完善的部分，建议抽离成单独文件。\n\n```javascript\n// 策略类\nlet strategies = {\n  isNotEmpty: function (value, errorMsg) {\n    if (value === '') {\n      return errorMsg || '非空'\n    }\n  },\n  minLength: function (value, length, errorMsg) {\n    if (value && value.length < length) {\n      return errorMsg || `长度不小于${length}`\n    }\n  },\n  maxLength: function (value, length, errorMsg) {\n    if (value && value.length > length) {\n      return errorMsg || `长度不大于${length}`\n    }\n  },\n  isMobile: function (value, errorMsg) {\n    if (!/(^1[3|5|8][0-9]{9}$)/.test(value)) {\n      return errorMsg || '输入正确的手机号'\n    }\n  },\n  isChinese: function (value, errorMsg) {\n    if (!/^[\\u4E00-\\u9FA5\\uf900-\\ufa2d0-9a-zA-Z]+$/.test(value)) {\n      return errorMsg || '输入字母/汉字/数字'\n    }\n  },\n  isIDCard: function (value, errorMsg) {\n    if (!/(^\\d{15}$)|(^\\d{17}(\\d|X|x)$)/.test(value)) {\n      return errorMsg || '输入正确的身份证'\n    }\n  },\n}\n\n// 环境类\nclass Validator {\n  constructor(name) {\n    this.caches = [];\n  }\n  // 添加校验规则的方法\n  add(value, rules) {\n    rules.map(rule => {\n      // 处理策略标识，支持minLength:5规则写法，可以根据需要自定义使用规则\n      let strategyArr = rule.strategy.split(/:|：/)\n      // 1.获取策略标识\n      let strategy = strategyArr.shift()\n      // 2.压入校验的值\n      strategyArr.unshift(value) // 头插入校验值\n      // 3.压入错误提示文字\n      strategyArr.push(rule.errMsg)\n      // 压入待校验的规则集合\n      this.caches.push(() => {\n        return strategies[strategy].apply(this, strategyArr)\n      })\n\n    })\n  }\n  // 开始执行校验\n  start() {\n    for (let validatorFun of this.caches) {\n      let errText = validatorFun()\n      if (errText) {\n        return errText\n      }\n    }\n  }\n}\n```\n\n### 直接单独使用\n\n默认已经导入`Validator`类，通过`new`关键词实例，存在`add`添加表单项和校验规则，执行`start`方法，若校验不通过，则返回提示信息，否则返回`undefined`，接下来查看演示代码段：\n\n```javascript\nlet validA = new Validator();\nlet validB = new Validator();\nlet aValue = ''; // 表单项a\nlet bValue = '1234'; // 表单项b\nvalidA.add(aValue, [\n  {\n    strategy: 'isNotEmpty',\n    errMsg: '不能为空'\n  },\n  {\n    strategy: 'minLength:5',\n    errMsg: '长度不能小于5'\n  }\n])\nvalidB.add(bValue, [\n  {\n    strategy: 'isNotEmpty',\n    errMsg: '不能为空'\n  },\n  {\n    strategy: 'minLength:5',\n    errMsg: '长度不能小于5'\n  }\n])\nconsole.log(validA.start()) // 不能为空\nconsole.log(validB.start()) // 长度不能小于5\n```\n\n### 一次校验多个表单项\n\n回顾`直接单独使用`演示的实例，代码量不少，何来优雅之谈。不可以一次校验多个表单项，返回校验不通过的信息，所以我们可以基于之前的**策略类**和**环境类**，简单封装一个使用方法，主要代码如下：\n\n```javascript\n// 策略类\n...\n\n// 环境类\n...\n\n// 使用辅助方法，返回最先校验不通过的提示\nfunction checkParamsByRules(arr) {\n  for (let item of arr) {\n    let v = new Validator();\n    v.add(item.value, item.rules);\n    let errText = v.start();\n    if (errText) {\n      return errText;\n    }\n  }\n}\n\n// 使用示例\nlet errText = checkParamsByRules([\n  {\n    value: '123567',\n    rules: [\n      {\n        strategy: 'isNotEmpty',\n        errMsg: '请输入信息'\n      },\n      {\n        strategy: 'minLength:5',\n        errMsg: '长度不能小于5'\n      },\n    ]\n  },\n  {\n    value: '0123456',\n    rules: [\n      {\n        strategy: 'isIDCard',\n        errMsg: '请输入身份证'\n      },\n    ]\n  },\n])\n\nconsole.log(errText) // 请输入身份证\n```\n\n### HUI/ElementUI中使用\n\n当然可以用于结合`el-form`组件使用，我们可以自定义使用规则，常规使用如下所示：\n\n```vue\n// template模版的内容\n<template>\n  <el-form\n  :rules=\"siteRules\"\n  :model=\"siteForm\"\n  >\n    <el-form-item label=\"名称\" prop=\"name\">\n      <el-input v-model=\"siteForm.name\" placeholder=\"请输入网站名\"></el-input>\n    </el-form-item>\n  </el-form>\n</template>\n\n// script模版的内容\n<script>\n  export default {\n    name: 'Demo'\n    data(){\n      \t// 定义校验规则\n        const checkEmpty = (rule, value, cb) => {\n        let vali = new Validator();\n        vali.add(value, [\n          {\n            strategy: 'isNotEmpty',\n            errMsg: '必填项',\n          },\n        ]);\n        let errText = vali.start();\n        if (errText) cb(new Error(errText)); // 存在报错则输出报错\n        cb(); // 正常放行\n      };\n      reture {\n        // el-form校验规则集\n        siteRules: {\n          name: [{ validator: checkEmpty, trigger: 'blur' }],\n      \t},\n      }\n    }\n  }\n</script>\n```\n\n\n\n## 策略模式的利弊\n\n### 优点\n\n1. 策略模式利于组合、委托、多态等技术思想，可以有效避免过多重复的条件选择语句；\n2. 完美地符合开放封闭原则，将算法封装在独立的策略类中，便于理解、替换、拓展；\n3. 自定义环境类中的定义属于团队自己的使用规则；\n\n### 缺点\n\n1. 违反知识最少原则，我们必须知道策略类内的各种策略算法的含义，才能上手使用；\n2. 一定程度上策略类会堆积很多算法；\n\n\n\n",
      "isDraft": "false",
      "publisher": "932397243@qq.com",
      "tag": "设计模式/表单校验/策略模式/实战",
      "time": "2022-5-31",
      "title": "策略模式在数据校验中的应用"
    },
    {
      "bannerImg": "huasen-public-static/admin/1664092489892.png",
      "code": "0",
      "content": "# 标题1\n\n> 批注批注批注\n\n标题一标题一标题一标题一标题一标题一标题一标题一标题一标题一标题一\n\n## 标题2\n\n标题2标题2标题2标题2标题2标题2标题2标题2标题2标题2\n\n### 标题3\n\n1. 条目1；\n2. 条目2；\n3. 条目3；\n\n#### 标题4\n\n- 第一条；\n- 第二条；\n\n## 标题2-测试图片\n\nimage image image image image image\n\n![](http://a.huasen.cc/server/huasen-public-static/admin/1664092489892.png)\n\n## 标题2-测试图表\n\n| Col1 | Col2 | Col3 |\n| ---- | ---- | ---- |\n| 1    | 2    | 3    |\n| 4    | 5    | 6    |\n| 7    | 8    | 9    |\n\n### 标题3-测试代码块\n\n```javascript\n你好 //普通话\nmwngz ndei //壮语\nhello //英语\nconsole.log('你好') //JS\n```\n\n### 标题3-测试着重\n\n着重着重着重着重着重着重着**重着**重着重着`重着`重着重着重着重着重着重着重着重着重\n\n# 免责声明\n\n严格遵守中华人民共和国相关法律，不存在破解、串改、贩卖数据等违法行为，一切资源均来源于各大免费论坛社区，包括提供的体验账号，仅供大家学习参考，请勿用于商业用途，违反者造成损失及法律责任与本人无关。如有不幸侵犯到您的权益，请联系小森，我们将全面积极配合！\n\n# 联系我们\n\n企鹅🐧：184820911\n\n邮箱📮：[184820911@qq.com](184820911@qq.com)\n\n哔哩哔哩：[花森酱JioJio](",
      "isDraft": "true",
      "publisher": "932397243@qq.com",
      "tag": "测试/效果",
      "time": "2022-9-25",
      "title": "markdown效果测试"
    }
  ]
}
